<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Echarts</title>
      <link href="/facd74f4.html"/>
      <content type="html"><![CDATA[<p>[toc]</p><h1 id="获取echarts-min-js"><a href="#获取echarts-min-js" class="headerlink" title="获取echarts.min.js"></a>获取echarts.min.js</h1><p><a href="https://echarts.baidu.com/download.html" target="_blank" rel="noopener">官网下载</a></p><blockquote><p>选择”在线定制”</p></blockquote><h1 id="修改图例、x轴或y轴文本字体颜色改变"><a href="#修改图例、x轴或y轴文本字体颜色改变" class="headerlink" title="修改图例、x轴或y轴文本字体颜色改变"></a>修改图例、x轴或y轴文本字体颜色改变</h1><p>修改legend（图例）字体颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> legend: &#123;</span><br><span class="line">    y:&apos;55%&apos;,</span><br><span class="line">    textStyle:&#123;</span><br><span class="line">        fontSize: 18,//字体大小</span><br><span class="line">        color: &apos;#ffffff&apos;//字体颜色</span><br><span class="line">    &#125;,</span><br><span class="line">    data: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改x轴字体颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xAxis : [</span><br><span class="line">    &#123;</span><br><span class="line">        type : &apos;category&apos;,</span><br><span class="line">        data : [],</span><br><span class="line">        axisLabel: &#123;</span><br><span class="line">            show: true,</span><br><span class="line">            textStyle: &#123;</span><br><span class="line">                color: &apos;#ffffff&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>修改y轴字体颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yAxis : [</span><br><span class="line">    &#123;</span><br><span class="line">        type : &apos;value&apos;,</span><br><span class="line">        nameTextStyle: &#123;</span><br><span class="line">            color: &apos;#ffffff&apos;</span><br><span class="line">        &#125;, // name的颜色值在这里改</span><br><span class="line">        name : &apos;&apos;,</span><br><span class="line">        axisLabel : &#123;</span><br><span class="line">            textStyle: &#123;</span><br><span class="line">                color: &apos;#ffffff&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h1 id="在一个页面同时显示多个不同形状的图表"><a href="#在一个页面同时显示多个不同形状的图表" class="headerlink" title="在一个页面同时显示多个不同形状的图表"></a>在一个页面同时显示多个不同形状的图表</h1><ol><li>采用两个id不同的div</li><li>设置series数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;//简单的 折线图+饼图 展示</span><br><span class="line">    grid: [</span><br><span class="line">        &#123;x: &apos;7%&apos;, y: &apos;7%&apos;, width: &apos;38%&apos;, height: &apos;38%&apos;&#125;,//折线图位置控制</span><br><span class="line">    ],</span><br><span class="line">    xAxis: [</span><br><span class="line">        &#123;gridIndex: 0,type: &apos;category&apos;,</span><br><span class="line">        data: [&apos;Mon&apos;, &apos;Tue&apos;, &apos;Wed&apos;, &apos;Thu&apos;, &apos;Fri&apos;]&#125;,</span><br><span class="line">    ],</span><br><span class="line">    yAxis: [</span><br><span class="line">        &#123;gridIndex: 0 &#125;,</span><br><span class="line">    ],</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            type: &apos;line&apos;,//折线图</span><br><span class="line">            xAxisIndex: 0,</span><br><span class="line">            yAxisIndex: 0,</span><br><span class="line">            data: [1,2,3,4,5],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            type: &apos;pie&apos;,</span><br><span class="line">            radius : &apos;45%&apos;,</span><br><span class="line">            center: [&apos;80%&apos;, &apos;30%&apos;],//饼图位置控制</span><br><span class="line">            data: [1,2,3,4,5],</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>H5</title>
      <link href="/2fca13d1.html"/>
      <content type="html"><![CDATA[<p>以前一直觉得video 添加 autoplay属性后，视频会自动播放没有问题，然而这次开发一个小项目用到video时才发现，设置autoplay属性不好使了，只有在controls的模式下点击播放按钮才可以播放。（我开发用的是mac,没试Windows下会不会有这个问题）</p><p>最后翻了很多资料说video标签中添加muted属性，亲测有效，代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;video muted src=&quot;&quot; autoplay loop&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>创意构想</title>
      <link href="/9c303927.html"/>
      <content type="html"><![CDATA[<p>[toc]</p><h2 id="答疑系统"><a href="#答疑系统" class="headerlink" title="答疑系统"></a>答疑系统</h2><ul><li>解决问题：<br>遇到疑难杂症，缺少大牛临场指导，甚至百度时根本不知道要搜的关键词是什么！</li><li>解决方案：<br>1.向聊天群管理员发出诉求，群管理向群员发布信息，参与讨论的群员有机会获得小红包，帮助解决问题的群员（由发布者确认）会获得大红包！提升群品质的同时，也可以创办线下活动增进群成员直接的感情。<br>2.打造一套实时在线体系，可以根据自己时间、悬赏金额、难度系数等来获取/发布任务，由管理员推荐涵盖各个专业领域的专家帮忙进行解答，金额足够高的话，专家甚至能为你远程手摸手交你操作！</li><li>需要设备：手机+电脑</li><li>方案扩展：暂无</li></ul><h2 id="调音大师"><a href="#调音大师" class="headerlink" title="调音大师"></a>调音大师</h2><ul><li>解决问题：手机里、电脑里的歌曲声音大小不一样，导致听歌时声音忽大忽小~</li><li>解决方案：通过调音大师app，可以把手机里的歌曲，根据预设的值，调成一样大小的声音，符合自己的听力习惯</li><li>需要设备：</li><li>方案扩展</li></ul><h2 id="便携式专车护栏"><a href="#便携式专车护栏" class="headerlink" title="便携式专车护栏"></a>便携式专车护栏</h2><ul><li>解决问题：专门为私家车提供，申请成为专车的私家车主（尤其是女司机），担心拉到的客人会侵犯自己</li><li>解决方案：在后备箱随时携带一套专车护栏，接单时就可安装上，拆装方便，坚固可靠，保证司机安全。</li><li>需要设备：专车护栏</li><li>方案扩展：</li></ul><h2 id="旅行箱万向轮锁定按钮"><a href="#旅行箱万向轮锁定按钮" class="headerlink" title="旅行箱万向轮锁定按钮"></a>旅行箱万向轮锁定按钮</h2><ul><li>解决问题：地铁上或者公交车上必须手不离箱，否则一个急刹车，旅行箱就滚到挡风玻璃前了！</li><li>解决方案：轮子锁定按钮，按下时可以令轮子无法转动，固定箱体位置</li><li>需要设备：箱体下方按钮</li><li>方案扩展</li></ul><h2 id="环境模拟大师"><a href="#环境模拟大师" class="headerlink" title="环境模拟大师"></a>环境模拟大师</h2><ul><li>解决问题：有时希望能在某个特点环境里接电话……你懂得~</li><li>解决方案：手机app，提供各种嘈杂的外界声音，为你接电话的时候，配上各种背景音，就能够模拟你在各种环境中……</li><li>需要设备：手机</li><li>方案扩展：无</li></ul><h2 id="智能管家APP"><a href="#智能管家APP" class="headerlink" title="智能管家APP"></a>智能管家APP</h2><ul><li>解决问题：整合手机里的资源，只打开一款APP，就可以控制手机里所有的APP。</li><li>解决方案：通过语音识别或养成类游戏方式，使自己的管家更贴合自己的习惯，以便智能管家做出预判，例如：管家知道使用者下班时间，可以提前叫车，或者询问是否能提前打开家里的智能设备。甚至如果有反常行为，智能管家会询问是否需要报警等帮助！</li><li>需要设备：手机</li><li>方案扩展：</li></ul><h2 id="随身饮水机"><a href="#随身饮水机" class="headerlink" title="随身饮水机"></a>随身饮水机</h2><ul><li>解决问题：不知道自己该喝多少水，改什么时候喝水</li><li>解决方案：先测试使用者的体质，来制定每天饮水的量和次数，定时喝水提醒，加水提示及自动断电等功能，</li><li>需要设备：饮水壶+杯子+APP</li><li>方案扩展：</li></ul><h2 id="安儿APP"><a href="#安儿APP" class="headerlink" title="安儿APP"></a>安儿APP</h2><ul><li>解决问题：新手宝爸宝妈面对超多品类婴儿用品无从下手</li><li>解决方案：通过社区新闻、扫一扫、手动记录等功能，记录下所有的禁忌，例如不能给孩子买什么药吃，哪种食品已经被列为转基因，哪个品牌有毒害等等，买东西时可查阅此款商品能不能买！</li><li>需要设备：手机</li><li>方案扩展：</li></ul><h2 id="地铁高峰期人群分流器"><a href="#地铁高峰期人群分流器" class="headerlink" title="地铁高峰期人群分流器"></a>地铁高峰期人群分流器</h2><ul><li>解决问题：高峰期地铁通道里，护栏两边经常是一侧人挤人，另一侧空空如也。</li><li>解决方案：利用人群分流器来调整通道的宽窄，以适应不同的人流量。</li><li>需要设备：（人群分流器设计）栏杆下方插入地面滑槽中，平时为左右均等，高峰时通过滑槽更改栏杆位置，使客流多的一方变宽～～</li><li>方案扩展：暂无</li></ul><h2 id="家庭试衣间"><a href="#家庭试衣间" class="headerlink" title="家庭试衣间"></a>家庭试衣间</h2><ul><li>解决问题：线上衣服不能试穿，常常出现尺码不合适，材质面料不满意等“买家秀”现象；实体店试衣间人满为患需要等待，在大众面前试衣失败的尴尬等。<br>解决方案：通过AI、3D打印等技术，可以让用户在家里完成试穿（尺码尝试），面料感知（3D打印）</li><li>需要设备：<br>  卖家 - 准确的衣服尺码，面料配方提供<br>  买家 - 全息测量仪，3D打印机</li><li>方案扩展：个人定制，slogan-我有我的size</li></ul><h2 id="共享单车回收计划"><a href="#共享单车回收计划" class="headerlink" title="共享单车回收计划"></a>共享单车回收计划</h2><p>用户提供故障单车位置信息，核实后会返给用户红包 —— 红包费<br>运营人员按照指定位置回收单车，统一修理（维修厂）—— 运输费，维修费，人工费<br>维修厂检验合格后再次投放 —— 运输费，人工费</p><h2 id="笑颜计划"><a href="#笑颜计划" class="headerlink" title="笑颜计划"></a>笑颜计划</h2><ol><li>产品现状如何，产品层面有哪些问题，运营层面有哪些问题，以及你准备怎么改进，给出执行方案和时间节点。</li><li>任务目标、分解及里程碑：用那些渠道/方式做推广，为什么选用这些渠道，大概会有什么样的效果，你能拿到什么价格，KPI 如何分解，需要多少预算。</li><li>如何收集产品数据，如何根据市场反应调整产品及推广策略，不同的数据反映代表了什么，如何做针对性调整。</li><li>用户如何维护，如何做用户运营，如何刺激转化，促活活动/荣誉体系/积分商城/产品粘性功能的设计。</li><li>产品的未来运营设想，应用场景拓展，营收情况预估，商业功能的设计。</li></ol><h2 id="在线答疑系统"><a href="#在线答疑系统" class="headerlink" title="在线答疑系统"></a>在线答疑系统</h2><p>选择要学习的科目，进行入学测试，根据测试结果，进行等级评定，制定学习计划。<br>选择白盒或黑盒模式，即每章测试或结业测试<br>利用行业大牛资源，一对一收费答疑，并且可以记录解决问题的过程，有偿分享给其他学员，减轻大牛压力（分答模式）</p>]]></content>
      
      <categories>
          
          <category> 创意构想 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS</title>
      <link href="/ee69e452.html"/>
      <content type="html"><![CDATA[<p>[toc]</p><h3 id="零-css-hack"><a href="#零-css-hack" class="headerlink" title="零. css hack"></a>零. css hack</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">height:32px;</span><br><span class="line">background-color:#f1ee18;/*所有识别*/</span><br><span class="line">.background-color:#00deff\9; /*IE6、7、8识别*/</span><br><span class="line">+background-color:#a200ff;/*IE6、7识别*/</span><br><span class="line">_background-color:#1e0bd1;/*IE6识别*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见css hack<br>|标记|IE6|IE7|IE8|FF|Opera|Sarari|<br>|:–:|:–:|:–:|:–:|:–:|:–:|:–:|<br>[*+&gt;&lt;]|√|√|X|X|X|X<br>_ |√ |X| X |X |X |X<br>\9 |√ |√ |√ |X |X |X<br>\0 |X |X |√ |X |√ |X<br>@media screen and (-webkit-min-device-pixel-ratio:0){.bb {}} |X| X| X |X| X |√<br>.bb , x:-moz-any-link, x:default| X |√ |X| √(ff3.5及以下) |X |X<br>@-moz-document url-prefix(){.bb{}} |X |X |X |√ |X |X<br>@media all and (min-width: 0px){.bb {}} |X |X |X |√ |√ |√</p><ul><li>+html .bb {} |X |√ |X |X |X |X<br>游览器内核 |Trident |Trident |Trident |Gecko |Presto |WebKit<br>注意：网上很多资料中常常把!important也作为一个hack手段，其实这是一个误区。!important常常被我们用来更改样式，而不是兼容hack。造成这个误区的原因是IE6在某些情况下不主动识别!important,以至于常常被人误用做识别IE6的hack。可是，大家注意一下，IE6只是在某些情况下不识别！==（ie6下，同一个大括号里对同一个样式属性定义，其中一个加important 则important标记是被忽略的，例：{background:red!important; background:green;} ie6下解释为背景色green，其它浏览器解释为背景色red；如果这同一个样式在不同大括号里定义，其中一个加important 则important发挥正常作用，例：div{background:red!important} div{background:green}，这时所有浏览器统一解释为背景色red。）==<h3 id="一-UL高度自适应"><a href="#一-UL高度自适应" class="headerlink" title="一. UL高度自适应"></a>一. UL高度自适应</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ul &#123;</span><br><span class="line">    min-height:450px;</span><br><span class="line">    height:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二-垂直居中"><a href="#二-垂直居中" class="headerlink" title="二. 垂直居中"></a>二. 垂直居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.chjz &#123;</span><br><span class="line">    justify-content:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-文本溢出显示省略号"><a href="#三-文本溢出显示省略号" class="headerlink" title="三. 文本溢出显示省略号"></a>三. 文本溢出显示省略号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow:hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">white-space:nowrap</span><br></pre></td></tr></table></figure><h3 id="四-鼠标滑过变成手型"><a href="#四-鼠标滑过变成手型" class="headerlink" title="四. 鼠标滑过变成手型"></a>四. 鼠标滑过变成手型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor:pointer;</span><br></pre></td></tr></table></figure><h3 id="五-pageX，clientX，screenX与offsetX"><a href="#五-pageX，clientX，screenX与offsetX" class="headerlink" title="五. pageX，clientX，screenX与offsetX"></a>五. pageX，clientX，screenX与offsetX</h3><p>先统一了解下这四个概念，理解不透没关系，咱们把概念相近的对比着一一细说。</p><p><strong>pageX</strong>：鼠标指针距离文档X轴左侧边缘的距离，不随滚动条变化而变化</p><p><strong>clientX</strong>：鼠标指针距离可视窗口左侧边缘的距离，随着滚动条变化而变化</p><p><strong>screenY</strong>：鼠标指针距离屏幕的距离(包括浏览器工具栏之类)，不随滚动条变化而变化</p><p><strong>offsetX</strong>：鼠标指针距离当前绑定元素左侧距离</p><p>我们先来看看pageX与clientX无滚动条的对比效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;one&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>JS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Div = document.querySelector(&apos;.one&apos;);</span><br><span class="line">Div.onmousemove = (e) =&gt; &#123;</span><br><span class="line">    var X1 = e.pageX;</span><br><span class="line">    var Y1 = e.pageY;</span><br><span class="line">    var X2 = e.clientX;</span><br><span class="line">    var Y2 = e.clientY;</span><br><span class="line">    Div.innerHTML = `pageX:$&#123;X1&#125;,pageY:$&#123;Y1&#125;,clientX:$&#123;X2&#125;,clientY:$&#123;Y2&#125;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://images2018.cnblogs.com/blog/1213309/201807/1213309-20180703231412077-1823777327.gif" alt="image"></p><p>由图可见，在无滚动条的情况下，pageX与clientX，pageY与clientY是完全相同的。</p><p>试着给div增加一个margin-left:1600px;让页面出现滚动条,我们将可视窗口滚动到最右侧，再来对比pageX与clientX<br><img src="https://images2018.cnblogs.com/blog/1213309/201807/1213309-20180703233058390-1398057900.gif" alt="image"></p><p>可以看到，在页面X轴出现滚动条后，pageX始终要比clientX要大，那是因为clientX无论滚动条滚动多少，它始终只计算鼠标到可视窗口左侧的距离，而pageX则还要加上滚动的距离</p><p><strong>pageX = 鼠标到可视窗口左侧距离+滚动条滚动距离(如果有滚动条)</strong></p><p><strong>clientX = 鼠标到可视窗口左侧距离</strong></p><p>如果没有滚动条，这两者的距离是完全相同的。</p><p>我们再结合前者，加上screenY与offsetY的对比，请看图</p><p><img src="https://images2018.cnblogs.com/blog/1213309/201807/1213309-20180705192704032-505698440.gif" alt="image"></p><p>为了方便对比，这里我们拿Y轴做对比。</p><p>offsetY是相对绑定事件的元素，这里是相对div，所以相比另外三个，Y轴的数值永远是最小的。</p><p>pageY和clientY在无滚动条的情况下是完全相同的，相对文档和可视窗口区域。这里因为没有滚动条，所以是完全相同的。</p><p>screen是相对屏幕，包含了浏览器任务栏，书签栏的高度，所以它永远是最高的。</p><p><img src="https://images2018.cnblogs.com/blog/1213309/201807/1213309-20180710190657953-1210472632.png" alt="image"></p><p>关于这四个的兼容问题，由于浏览的不断更新，比如offsetX很多博客都说是IE独有的，结果上图我全是在谷歌测试的，也是支持的，所以这样的说法过于绝对，是不完全正确的。</p><ol><li>offsetLeft与style.left</li></ol><p>==下面概念中的position值为非static时，可以理解为position为relative,absolute,fixed其一==</p><p>2.1  <strong>offsetLeft</strong>：</p><p>元素相对其定位父级(offsetParent)的左偏移量。</p><p>简单去理解，就是距离元素最近且position值非static父级元素的左偏移量，如果向上一直未找到，则相对body。</p><p>假设此时一个父级div包含一个子级div，均未定位，父级margin-left为20px,子级margin-left为30px，且父级border为2px</p><p>我们上面说了，从子级开始往上找定位父级，但是未找到，那么此时就相对body</p><p>那么子级的offsetLeft = 父级左偏移量20px+子级30px+父级边框2px</p><p><img src="https://images2018.cnblogs.com/blog/1213309/201806/1213309-20180630184818504-1404984772.png" alt="image"> </p><p>我们尝试给父级div添加一个position：absolute属性，其余属性全部不做改变，此时子级的定位父级就是自己的上级div，因此offsetLeft为30px</p><p><img src="https://images2018.cnblogs.com/blog/1213309/201806/1213309-20180630190135583-27643525.png" alt="image"></p><p>2.2  style.left：</p><p>获取元素相对其定位父级的左偏移，且元素本身position值为非static。</p><p>简单去理解，style.left只有元素自身进行定位才会有效，否则是无法取到的。</p><p>2.3  为什么style.left取不到？</p><p>首先元素本身要进行定位，其次，其left属性为内部样式时才能获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&apos;left=20px&apos;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>2.4   offsetLeft与style.left的区别</p><p>1.获取offsetLeft属性的元素自身不用定位，但获取style.left的元素必须定位<br>2.offsetLeft是只读的，style.left是读写的<br>3.offsetLeft返回的是数字，不带单位，style.left 返回的是字符串，带单位<br>4.style.left 只能获取定义在html中的内部样式属性，而offsetLeft并没有这个限制<br>2.5  同时存在margin-left与left时的offsetLeft<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;&lt;div class=&quot;child&quot; style=&apos;left:20px&apos;&gt;&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://images2018.cnblogs.com/blog/1213309/201806/1213309-20180630192936546-1849339119.png" alt="image"></p><p> 需要注意的是，当margin与left，外边距与定位偏移量同时存在时，它们是累加的，并不会发生重叠。</p><ol><li>offsetwidth,clientWidth与scrollWidth</li></ol><p>我们先来看看这三者的含义</p><p><strong>offsetwidth</strong>：获取元素的宽度，包含border，padding和元素的width，不包含margin</p><p><strong>clientWidth</strong>:获取元素内容区域的宽度，包括padding与元素的width，不包含border与margin</p><p><strong>scrollWidth</strong>：获取元素的宽度，包含padding和width，不包含border与margin</p><ol><li><h4 id="clientTop，scrolleTop"><a href="#clientTop，scrolleTop" class="headerlink" title="clientTop，scrolleTop"></a>clientTop，scrolleTop</h4></li></ol><p><strong>scrolleTop</strong>:获取元素滚动后的距离文档顶部的距离，也就是滚动条滚动的距离。</p><p><strong>clientTop</strong>:获取元素边框的厚度，也就是border的宽度。</p><h3 id="六-iframe的高度自适应"><a href="#六-iframe的高度自适应" class="headerlink" title="六. iframe的高度自适应"></a>六. iframe的高度自适应</h3><ol><li>子页面html节点上要有下面这部分，不然ie浏览器会无限递增<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br></pre></td></tr></table></figure></li></ol><p>页面部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;mainFrame&quot; name=&quot;mainFrame&quot; scrolling=&quot;no&quot; src=&quot;Index.aspx&quot;</span><br><span class="line">            frameborder=&quot;0&quot; style=&quot;padding: 0px; width: 100%; height: 1000px;&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p><p>父页面调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  startInit(&apos;mainFrame&apos;, 560);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>//父页面加入下面js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var browserVersion = window.navigator.userAgent.toUpperCase();</span><br><span class="line">var isOpera = browserVersion.indexOf(&quot;OPERA&quot;) &gt; -1 ? true : false;</span><br><span class="line">var isFireFox = browserVersion.indexOf(&quot;FIREFOX&quot;) &gt; -1 ? true : false;</span><br><span class="line">var isChrome = browserVersion.indexOf(&quot;CHROME&quot;) &gt; -1 ? true : false;</span><br><span class="line">var isSafari = browserVersion.indexOf(&quot;SAFARI&quot;) &gt; -1 ? true : false;</span><br><span class="line">var isIE = (!!window.ActiveXObject || &quot;ActiveXObject&quot; in window);</span><br><span class="line">var isIE9More = (! -[1,] == false);</span><br><span class="line">function reinitIframe(iframeId, minHeight) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var iframe = document.getElementById(iframeId);</span><br><span class="line">        var bHeight = 0;</span><br><span class="line">        if (isChrome == false &amp;&amp; isSafari == false) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                bHeight = iframe.contentWindow.document.body.scrollHeight;</span><br><span class="line">            &#125; catch (ex) &#123;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var dHeight = 0;</span><br><span class="line">        if (isFireFox == true)</span><br><span class="line">            dHeight = iframe.contentWindow.document.documentElement.offsetHeight + 2;//如果火狐浏览器高度不断增加删除+2</span><br><span class="line">        else if (isIE == false &amp;&amp; isOpera == false &amp;&amp; iframe.contentWindow) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                dHeight = iframe.contentWindow.document.documentElement.scrollHeight;</span><br><span class="line">            &#125; catch (ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (isIE == true &amp;&amp; isIE9More) &#123;//ie9+</span><br><span class="line">            var heightDeviation = bHeight - eval(&quot;window.IE9MoreRealHeight&quot; + iframeId);</span><br><span class="line">            if (heightDeviation == 0) &#123;</span><br><span class="line">                bHeight += 3;</span><br><span class="line">            &#125; else if (heightDeviation != 3) &#123;</span><br><span class="line">                eval(&quot;window.IE9MoreRealHeight&quot; + iframeId + &quot;=&quot; + bHeight);</span><br><span class="line">                bHeight += 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else//ie[6-8]、OPERA</span><br><span class="line">            bHeight += 3;</span><br><span class="line"></span><br><span class="line">        var height = Math.max(bHeight, dHeight);</span><br><span class="line">        if (height &lt; minHeight) height = minHeight;</span><br><span class="line">        //alert(iframe.contentWindow.document.body.scrollHeight + &quot;~&quot; + iframe.contentWindow.document.documentElement.scrollHeight);</span><br><span class="line">        iframe.style.height = height + &quot;px&quot;;</span><br><span class="line">    &#125; catch (ex) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">function startInit(iframeId, minHeight) &#123;</span><br><span class="line">    eval(&quot;window.IE9MoreRealHeight&quot; + iframeId + &quot;=0&quot;);</span><br><span class="line">    window.setInterval(&quot;reinitIframe(&apos;&quot; + iframeId + &quot;&apos;,&quot; + minHeight + &quot;)&quot;, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在iframe页面地址更改前，将iframe高度设置为0，清除上一个子页面高度的影响，google内核浏览器的高度才会自动缩减<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;mainFrame&quot;).style.height = &quot;0px&quot;;//最好设置为minHeight</span><br><span class="line">//$(&quot;#mainFrame&quot;).height(0);</span><br><span class="line">$(&quot;#mainFrame&quot;).attr(&quot;src&quot;, url);</span><br></pre></td></tr></table></figure></p><ol><li>利用window.onresize，它的作用就是当窗口大小改变的时候会触发这个事件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function changeFrameHeight()&#123;</span><br><span class="line">    var ifm= document.getElementById(&quot;iframepage&quot;); </span><br><span class="line">    ifm.height=document.documentElement.clientHeight;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onresize=function()&#123;  </span><br><span class="line">     changeFrameHeight();  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="七-input等标签点击时没有蓝色框"><a href="#七-input等标签点击时没有蓝色框" class="headerlink" title="七. input等标签点击时没有蓝色框"></a>七. input等标签点击时没有蓝色框</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input,</span><br><span class="line">textarea,</span><br><span class="line">select,</span><br><span class="line">a:focus &#123;</span><br><span class="line">  outline: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、Table"><a href="#八、Table" class="headerlink" title="八、Table"></a>八、Table</h3><p>1、边框合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">table&#123;</span><br><span class="line"></span><br><span class="line">border-collapse: collapse;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="九、三列布局，两边宽度固定中间自适应"><a href="#九、三列布局，两边宽度固定中间自适应" class="headerlink" title="九、三列布局，两边宽度固定中间自适应"></a>九、三列布局，两边宽度固定中间自适应</h3><p><a href="https://blog.csdn.net/a18792627168/article/details/79686746" target="_blank" rel="noopener">https://blog.csdn.net/a18792627168/article/details/79686746</a></p>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>各种报错</title>
      <link href="/8d969c4d.html"/>
      <content type="html"><![CDATA[<p>[toc]</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="VUE报错"><a href="#VUE报错" class="headerlink" title="VUE报错"></a>VUE报错</h3><h4 id="1-vue提示模板错误"><a href="#1-vue提示模板错误" class="headerlink" title="1. vue提示模板错误"></a>1. vue提示模板错误</h4><p>==错误信息：==<br>You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.<br><strong>原因：</strong> vue默认配置的是runtime版本。   </p><blockquote><p>不同构建版本的解释说明</p></blockquote><p>在<b style="color:#65b687">NPM包的</b> <b style="color:#da702b">dist/</b> <b style="color:#65b687">目录下</b>，你会找到许多不同构建版本的 Vue.js。以下是它们之间差异的概述：<br>| |UMD|CommonJS|ES Module<br> —|:–:|:–:|:–:<br>完整版本(Full)|vue.js|vue.common.js|vue.esm.js|<br>只含有运行时版本(Runtime-only)|vue.runtime.js|    vue.runtime.common.js|vue.runtime.esm.js|<br>完整版本（生产环境）|vue.min.js|-|-|<br>只含有运行时版本（生产环境）|vue.runtime.min.js|-|-|<br>==解决办法：==<br><b style="color:#da702b">webpack.config.js</b> 添加如下配置  </p><blockquote><p>vue-cli3.0后好像配置文件不叫webpack.config.js这个名字了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">        vue: &apos;vue/dist/vue.js&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue/dist/vue.js&apos;;</span><br></pre></td></tr></table></figure></p><p>或者<br>提取vue在html文件中直接引用(这种方法不推荐)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><b style="color:#da702b">webpack.config.js</b> 添加如下配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  vue: &apos;Vue&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="2-在vue-cli里引入jQuery"><a href="#2-在vue-cli里引入jQuery" class="headerlink" title="2. 在vue-cli里引入jQuery"></a>2. 在vue-cli里引入jQuery</h4><p>1）安装jquery依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jquery  –save</span><br></pre></td></tr></table></figure></p><p>2）修改两处webpack配置 <b style="color:#da702b">*注意vue-cli3.0以后不再有webpack.config.js这个文件，需要写在vue.config.js里</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;)//第一步，请求webpack</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  lintOnSave: false,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      new webpack.ProvidePlugin(&#123;  //第二步，引入Jquery</span><br><span class="line">        $: &apos;jquery&apos;,</span><br><span class="line">        jQuery: &apos;jquery&apos;,</span><br><span class="line">        &apos;window.jQuery&apos;:&apos;jquery&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3）需要在那个页面用，直接引入即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import $ from ‘jquery’</span><br></pre></td></tr></table></figure></p><h4 id="3-vue监听window-onresize方法"><a href="#3-vue监听window-onresize方法" class="headerlink" title="3. vue监听window.onresize方法"></a>3. vue监听window.onresize方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div :style=&quot;&#123;width: `$&#123;screenWidth&#125;px`&#125;&quot;&gt;</span><br><span class="line">      &lt;router-view/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      screenWidth: document.body.clientWidth</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    const that = this</span><br><span class="line">    window.onresize = () =&gt; &#123;</span><br><span class="line">      return (() =&gt; &#123;</span><br><span class="line">        window.screenWidth = document.body.clientWidth</span><br><span class="line">        that.screenWidth = window.screenWidth</span><br><span class="line">      &#125;)()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    screenWidth (val) &#123;</span><br><span class="line">      this.screenWidth = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="4-Vue项目刷新当前页"><a href="#4-Vue项目刷新当前页" class="headerlink" title="4. Vue项目刷新当前页"></a>4. Vue项目刷新当前页</h4><p><a href="https://blog.csdn.net/qq_16772725/article/details/80467492" target="_blank" rel="noopener">链接</a></p><h3 id="NPM报错"><a href="#NPM报错" class="headerlink" title="NPM报错"></a>NPM报错</h3><h4 id="1-code-128"><a href="#1-code-128" class="headerlink" title="1. code 128"></a>1. code 128</h4><p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global url.&quot;https://&quot;.insteadOf git://</span><br></pre></td></tr></table></figure></p><h4 id="2-code-13"><a href="#2-code-13" class="headerlink" title="2. code 13"></a>2. code 13</h4><p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xxx...</span><br></pre></td></tr></table></figure></p><h4 id="3-npm-install-报错chromedriver-记录，错误信息如下："><a href="#3-npm-install-报错chromedriver-记录，错误信息如下：" class="headerlink" title="3. npm install 报错chromedriver 记录，错误信息如下："></a>3. npm install 报错chromedriver 记录，错误信息如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! chromedriver@2.34.1 install: `node install.js`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! Failed at the chromedriver@2.34.1 install script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br></pre></td></tr></table></figure><p>该问题是vue-cli脚手架的一个bug，解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver</span><br></pre></td></tr></table></figure></p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><h4 id="1-项目运行时一直发http-localhost-8080-sockjs-node-info-t-1462183700002请求"><a href="#1-项目运行时一直发http-localhost-8080-sockjs-node-info-t-1462183700002请求" class="headerlink" title="1. 项目运行时一直发http://localhost:8080/sockjs-node/info?t=1462183700002请求"></a>1. 项目运行时一直发<a href="http://localhost:8080/sockjs-node/info?t=1462183700002请求" target="_blank" rel="noopener">http://localhost:8080/sockjs-node/info?t=1462183700002请求</a></h4><p>如图：<br><img src="img/aiqianduan/WX20200318-182153@2x.png" alt="wx20200314-151251@2x.png"><br>首先sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。<br>如果你的项目没有用到sockjs,vuecli3 运行npm run serve 之后network里面一直调用一个接口:<br><a href="http://localhost:8080/sockjs-node/info?t=1556418283950" target="_blank" rel="noopener">http://localhost:8080/sockjs-node/info?t=1556418283950</a></p><p>方案：从根源上关闭此调用</p><p>1、node_modules/sockjs-client/dist/sockjs.js</p><p>2、代码的1605行注释<br>// self.xhr.send(payload);<br>ps:可在代码开发完成后关闭，会同步关闭热加载</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><h4 id="1-使用-gitkeep来追踪空的文件夹"><a href="#1-使用-gitkeep来追踪空的文件夹" class="headerlink" title="1. 使用.gitkeep来追踪空的文件夹"></a>1. 使用.gitkeep来追踪空的文件夹</h4><p>解决办法：<br>Git会忽略空的文件夹。如果你想版本控制包括空文件夹，根据惯例会在空文件夹下放置.gitkeep文件。其实对文件名没有特定的要求。一旦一个空文件夹下有文件后，这个文件夹就会在版本控制范围内。</p><h4 id="2-当用git命令拉取最新代码时，有时会遇到如下的提示，-Found-a-swap-file-by-the-name-“-git-MERGE-MSG-swp”"><a href="#2-当用git命令拉取最新代码时，有时会遇到如下的提示，-Found-a-swap-file-by-the-name-“-git-MERGE-MSG-swp”" class="headerlink" title="2. 当用git命令拉取最新代码时，有时会遇到如下的提示， Found a swap file by the name “.git/.MERGE_MSG.swp”"></a>2. 当用git命令拉取最新代码时，有时会遇到如下的提示， Found a swap file by the name “.git/.MERGE_MSG.swp”</h4><p>在项目根目录（如/StudioProjects/demo/Leave）下，找到.git/.MERGE_MSG.swp这个文件删除即可。 注：mac 删除命令rm -rf .MERGE_MSG.swp</p><h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><h4 id="1-ES6"><a href="#1-ES6" class="headerlink" title="1. ES6"></a>1. ES6</h4><p>使用es6可能导致安卓端真机调试时很多问题出现，还有其他未知问题；原因未知；</p><h4 id="2-字母拼错"><a href="#2-字母拼错" class="headerlink" title="2. 字母拼错"></a>2. 字母拼错</h4><p>包括字母拼写错误，大小写没有注意；微信小程序中，有大量这样的代码示例，从中间冒出一个大写，比如支付中的appId</p><h4 id="3-官方文档示例代码有误"><a href="#3-官方文档示例代码有误" class="headerlink" title="3. 官方文档示例代码有误"></a>3. 官方文档示例代码有误</h4><p>有时官方文档示例代码也会出现问题，比如大小写出错，或者其他缺少参数等问题；</p><h4 id="4-https"><a href="#4-https" class="headerlink" title="4. https"></a>4. https</h4><p>这个坑目前遇到的人最多，首先说明一下，工具的这个设置，<br><img src="img/aiqianduan/WX20200318-182245@2x.png" alt="wx20200314-150320@2x.png"><br>，这个设置有一些独特的作用，让你可以让本地避开一些限制；但是这个设置对真机无效，所以假如存在https问题，是否勾选并影响；仍然需要按贴排查：<a href="http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=648" target="_blank" rel="noopener">http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=648</a></p><h4 id="5-官方BUG"><a href="#5-官方BUG" class="headerlink" title="5. 官方BUG"></a>5. 官方BUG</h4><p>你遇到的问题可能是官方仍未解决的bug，具体可以参考官方文档<br><a href="http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1360&amp;highlight=%E9%9D%A2%E5%90%91%E6%96%B0%E6%89%8B" target="_blank" rel="noopener">面向新手系列《四》官方文档BUG，tip及QA提示一览</a>，以及最新的官方回答，目前有两个官方帮助，但是仅限于12月20号，更多更新，可以在本站搜索关键词“官方”或前往官方开发者社区查询；<a href="http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1353&amp;highlight=%E5%AE%98%E6%96%B9" target="_blank" rel="noopener">微信小程序官方帮助出来了，你最想吐槽的是什么坑？</a><br><a href="http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1507&amp;highlight=%E5%AE%98%E6%96%B9" target="_blank" rel="noopener">官方问答精选系列《一》提交审核时提供测试账密码</a></p><h4 id="6-官方文档"><a href="#6-官方文档" class="headerlink" title="6. 官方文档"></a>6. 官方文档</h4><p>官方文档是解决问题的不二之选，建议在解决问题时，不断的看官方文档，并且仔细看，尽量从官方文档中找出解决方案；</p><h4 id="7-调试工具"><a href="#7-调试工具" class="headerlink" title="7. 调试工具"></a>7. 调试工具</h4><p>官方开发者工具及手机端，都提供了调试工具，基本跟原本大家常用的调试工具相差无几，可用利用调试工具多做各种调试，以免排查问题；调试方法，新手可以搜索网上相关firebug教程或浏览器调试教程或调试教程；</p><h4 id="8-重启大法"><a href="#8-重启大法" class="headerlink" title="8. 重启大法"></a>8. 重启大法</h4><p>有时候编辑器会出现一些莫名其妙的BUG，比如昨天还是好的，今天打开各种问题等等，可以考虑重新编译或多次重启工具或重启电脑；</p><h4 id="9-新手跳坑"><a href="#9-新手跳坑" class="headerlink" title="9. 新手跳坑"></a>9. 新手跳坑</h4><p>我们为新手准备了很多<a href="http://www.wxapp-union.com/forum.php?mod=forumdisplay&amp;fid=2&amp;filter=typeid&amp;typeid=3" target="_blank" rel="noopener">常见问题</a></p><h4 id="10-前人经验"><a href="#10-前人经验" class="headerlink" title="10. 前人经验"></a>10. 前人经验</h4><p>有很多人遇到了很多问题，你可以在版块的问答分类下看看<a href="http://www.wxapp-union.com/forum.php?mod=forumdisplay&amp;fid=2&amp;page=2&amp;filter=author&amp;orderby=dateline&amp;typeid=16" target="_blank" rel="noopener">其他人遇到的问题及如此解决的</a></p><h4 id="11-无法登陆"><a href="#11-无法登陆" class="headerlink" title="11. 无法登陆"></a>11. 无法登陆</h4><p>参考@M-信念 同学的建议：可以稍微等等；当出现帐号登陆问题时，可以尝试使用他人微信号，或是咨询其他人是否也遇到了相同的情况，不要着急；</p><h4 id="12-代理设置"><a href="#12-代理设置" class="headerlink" title="12. 代理设置"></a>12. 代理设置</h4><p>代理设置应该是一个隐藏比较深的坑，但是很多人被坑过，假如你的机器设置了代理，开发者工具可能会也跟着默认带来代理，然后会接踵而来很多登陆，空白等问题；<br><img src="img/aiqianduan/WX20200318-182347@2x.png" alt="wx20200314-150908@2x.png"></p><h4 id="13-使用搜索"><a href="#13-使用搜索" class="headerlink" title="13. 使用搜索"></a>13. 使用搜索</h4><p>现在本站聚合了大量的微信小程序相关内容，可以考虑使用本站的搜索，来获取自己想找的东西或用于解决问题，搜索时，请使用主要关键词，或相近关键词进行搜索，而不要直接搜索一句话，比如你需要appid，你可以搜索“appid”，你遇到了登陆问题，应该搜索“登陆”，真机预览遇到了问题，可以搜索“真机”，遇到了上传问题，可以搜索“uploadfile”</p><h4 id="14-微信版本问题"><a href="#14-微信版本问题" class="headerlink" title="14. 微信版本问题"></a>14. 微信版本问题</h4><p>伴随微信的版本更新，不同的微信版本之间可能会出现不同的未知BUG；</p><h4 id="15-微信缓存"><a href="#15-微信缓存" class="headerlink" title="15. 微信缓存"></a>15. 微信缓存</h4><p>微信缓存会导致很多未知的bug，目前发现的有无法真机预览，以及跳出错误：需要清除应用缓存，或者使用第二部手机进行测试方可排除此问题；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">On PageReady can not find XXXXXX, app service not ready</span><br></pre></td></tr></table></figure></p><h4 id="16-使用了非官方提供的方法"><a href="#16-使用了非官方提供的方法" class="headerlink" title="16. 使用了非官方提供的方法"></a>16. 使用了非官方提供的方法</h4><p>使用了部分非官方提供的方法比如Object.assign，可能会导致未知的问题，建议优先使用官方组件来实现；</p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><h4 id="1-使用brew-install-mongodb安装mongodb时提示：No-available-formula-with-the-name-“mongodb”。。。因为MongoDB不再开源了！所以之前网上安装的方法都不对了！"><a href="#1-使用brew-install-mongodb安装mongodb时提示：No-available-formula-with-the-name-“mongodb”。。。因为MongoDB不再开源了！所以之前网上安装的方法都不对了！" class="headerlink" title="1. 使用brew install mongodb安装mongodb时提示：No available formula with the name “mongodb”。。。因为MongoDB不再开源了！所以之前网上安装的方法都不对了！"></a>1. 使用brew install mongodb安装mongodb时提示：No available formula with the name “mongodb”。。。因为MongoDB不再开源了！所以之前网上安装的方法都不对了！</h4><p>官网解决步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 首先tap一个仓库</span><br><span class="line">brew tap mongodb/brew</span><br><span class="line">// 安装社区版（商业版没研究～）</span><br><span class="line">brew install mongodb-community@4.2</span><br><span class="line">// 后面的@4.2省略应该也行，默认安装最新版本（安装时最新4.2）</span><br></pre></td></tr></table></figure></p><h4 id="2-关于-data-db"><a href="#2-关于-data-db" class="headerlink" title="2. 关于/data/db"></a>2. 关于/data/db</h4><p>安装完MongoDB后，用mongod命令启动，此时会报错，因为没有数据库存放目录，必须创建一个。不知道为什么命令行一直失效，于是手动在/User/fu下面创建/data文件夹，再在其中创建/db文件夹，并用命令行启动MongoDB数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mongod --dbpath /Users/fu/data/db</span><br></pre></td></tr></table></figure></p><blockquote><p>注意一定要加sudo！否则启动会失败~</p></blockquote><p>然后打开一个新的终端窗口，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure></p><p>当看到“ &gt; ”时，说明成功进入mongo的REPL环境(Read-Eval-Print-Loop，读一句、执行一句、显示一句)，此时便可以利用命令行进行数据库操作了</p>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>爱前端笔记</title>
      <link href="/8d969c4d.html"/>
      <content type="html"><![CDATA[<p>[toc]</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><ul><li>概述：H5新增双闭合标签，它主要的功能是可以让我们写一些小游戏。</li><li>资料：<a href="https://www.canvasapi.cn" target="_blank" rel="noopener">API</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Basic_usage" target="_blank" rel="noopener">手册</a><h3 id="一-canvas的基本使用"><a href="#一-canvas的基本使用" class="headerlink" title="一. canvas的基本使用"></a>一. canvas的基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123; margin: 0; padding: 0;&#125;</span><br><span class="line">        canvas &#123; border: 1px solid black;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;canvas width=&quot;600px&quot; height=&quot;300px&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：canvas有默认的宽和高(300*150px)，如果要改宽高，只能在行间样式中修改！canvas最终相当于是一张图片</p></blockquote><ol><li>canvas绘制基本图形<br>如果想在canvas上绘制图形，需要使用canvas2D上下文； </li></ol><h2 id="nodeJS"><a href="#nodeJS" class="headerlink" title="nodeJS"></a>nodeJS</h2><h3 id="开门注"><a href="#开门注" class="headerlink" title="开门注"></a>开门注</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>介绍：</p><ul><li>Node.js是一个构建在Chrome浏览器V8引擎上的JavaScript运行环境；</li><li>Node.js使用了事件驱动、非阻塞I/O模型，这些都使它轻量、好用；</li><li>Node.js的包生态(npm)，是世界上最大的开源生态系统。</li></ul><h4 id="1-JavaScript到底出了什么问题？"><a href="#1-JavaScript到底出了什么问题？" class="headerlink" title="1. JavaScript到底出了什么问题？"></a>1. JavaScript到底出了什么问题？</h4><p>先说说异步I/O和同步I/O：绝大多数的网站I/O是非常多的，I就是input(数据的读取)，O就是output(数据的写入)，但I/O的时候CPU命令磁盘去做事情，此时CPU就闲置了。这种模式叫做同步I/O</p><ul><li>同步(synchronous)：当系统遇见了一个需要耗费大量时间的事情时，选择死等。</li><li>异步(Asynchronous)：当系统遇见了一个需要耗费大量时间的事情时，不死等，先做后面的时期，耗时事情做完之后，执行回调函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&quot;./test.txt&quot;, function(err, data)&#123;</span><br><span class="line">    console.log(data.toString()); // 后输出</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var sum = 0;</span><br><span class="line">for(var i=0; i&lt;=100; i++)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum); // 先输出</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Node.js解决性能问题使用非常极端的思想：预期一堆服务员闲着，还不如一个服务员往死里用。</p></blockquote><h4 id="2-Node-js创建服务器-node-js"><a href="#2-Node-js创建服务器-node-js" class="headerlink" title="2. Node.js创建服务器(node.js)"></a>2. Node.js创建服务器(node.js)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 读取内置模块http，这个模块是开发服务器用的</span><br><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line">// 创建一个服务器</span><br><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">    // req表示请求，res表示响应</span><br><span class="line">    // 设置下行请求的头部信息(否则会出现乱码)</span><br><span class="line">    res.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">    // 每个服务器都必须有一个end，即使为空！否则页面会一直处于loading状态，end里面必须是字符串或者二进制</span><br><span class="line">    res.end(&quot;&lt;h1&gt;我买了iPhone&quot; + (3 + 4) + &quot;&lt;/h1&gt;&quot;)</span><br><span class="line">&#125;);</span><br><span class="line">// 监听</span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure><p>运行：在文件所在目录下打开终端，使用下面的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node node.js</span><br></pre></td></tr></table></figure></p><p>Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端。但Node.js似乎和其他服务端语言比如PHP、ASP、JSP有点不同：</p><ul><li>Node.js不是一种独立的语言，与PHP、JSP、Python、Ruby的“既是语言，也是平台”不同，Node.js使用JavaScript进行编程，运行在JavaScript引擎上(V8)</li><li>与PHP、JSP等相比，Node.js跳过了Apache、Nginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构(LAMP)有着很大的不同，可以提供强大的伸缩能力.</li><li>Node.js自身哲学，就是花最小的硬件成本，追求更高的并发，更高的处理性能。</li><li>Node.js没有根目录的概念。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(浏览器) --&gt;|1.发送request请求|B[服务器2.nodejs程序在这里执行]</span><br><span class="line">B[服务器:2.nodejs程序在这里执行] --&gt;|3.返回response响应|A(浏览器)</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Node-js的特点："><a href="#3-Node-js的特点：" class="headerlink" title="3. Node.js的特点："></a>3. Node.js的特点：</h4><ul><li>单线程特性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line">var a = 0;</span><br><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    res.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">    // 每个服务器都必须有一个end，即使为空！否则页面会一直处于loading状态，end里面必须是字符串或者二进制</span><br><span class="line">    res.end(a.toString());</span><br><span class="line">&#125;);</span><br><span class="line">// 监听</span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure></li></ul><p>每次刷新a都会自增，说明没有新开进程，证明Node.js是单线程的</p><blockquote><p>Node.js拥有JS的所有核心语法，包括ES6语法。但是Node.js没有BOM的东西，比如window对象等。</p></blockquote><p>下面的程序一旦刷到6666，将抛出错误，然后程序会挂起，不能再被访问！侧面证明了Node.js是单线程的！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">    var num = parsInt(Math.random() * 1000)</span><br><span class="line">    if(num === 6666)&#123;</span><br><span class="line">        throw new Error(&quot;错误！6666出现了！这个人的ip是&quot; + req.connection.remoteAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    res.end(&quot;你的数字是&quot; + num);</span><br><span class="line">&#125;);</span><br><span class="line">// 监听</span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure></p><ul><li>异步I/O特性：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;); // 创建服务器用的</span><br><span class="line">var fs = require(&quot;fs&quot;); // 读取文件用的</span><br><span class="line"></span><br><span class="line">var ip = req.connection.remoteAddress;</span><br><span class="line">console.log(ip + &quot;来了！开始读取文件！&quot;);</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">    // 来客人之后做的事情</span><br><span class="line">    fs.readFile(&quot;./test.txt&quot;, function(err, data)&#123;</span><br><span class="line">       res.end(data); </span><br><span class="line">       console.log(ip + &quot;读取文件完毕！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">// 监听</span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure></li></ul><p>可以看到一个ip开始读到读完之间，会插入别的ip开始读的情况！这就是异步I/O。==只要I/O越多，Node.js宏观上越并行==<br><img src="img/aiqianduan/WX20200318-174327@2x.png" alt="wx20200312-140205@2x.png"><br>而如果==计算越多，Node.js宏观上越不并行==，CPU将被某个线程单独占用！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;); // 创建服务器用的</span><br><span class="line">var fs = require(&quot;fs&quot;); // 读取文件用的</span><br><span class="line"></span><br><span class="line">var ip = req.connection.remoteAddress;</span><br><span class="line">console.log(ip + &quot;来了！开始计算水仙花数！&quot;);</span><br><span class="line">for(var i=1000; i&lt;=9999; i++)&#123;</span><br><span class="line">    var ge = i % 10,</span><br><span class="line">        shi = parsInt(i / 10) % 10,</span><br><span class="line">        bai = parsInt(i / 100) % 10,</span><br><span class="line">        qian = parsInt(i / 1000) % 10;</span><br><span class="line">    var sum = Math.pow(ge,4) + Math.pow(shi,4) + Math.pow(bai,4) + Math.pow(qian,4);</span><br><span class="line">    if(sum == i)&#123;</span><br><span class="line">        console.log(ip + &quot;算出了水仙花数！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(ip + &quot;开始读取文件！&quot;);</span><br><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">    // 来客人之后做的事情</span><br><span class="line">    fs.readFile(&quot;./test.txt&quot;, function(err, data)&#123;</span><br><span class="line">       res.end(data); </span><br><span class="line">       console.log(ip + &quot;读取文件完毕！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">// 监听</span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure></p><p><img src="img/aiqianduan/WX20200318-174409@2x.png" alt="wx20200312-140924@2x.png"></p><blockquote><p>Node.js适合I/O多的业务，例如：用户表单收集、考试系统、打分系统、聊天室、图文直播、提供JSON的API(为前台Angular等使用)……而不适合计算多的业务！</p></blockquote><p><img src="img/aiqianduan/WX20200318-174421@2x.png" alt="wx20200312-141558@2x.png"></p><ul><li>事件驱动特性：事件驱动是Node.js的底层机制，我们只需要了解Node.js不会“上错菜”的原因就是事件驱动——事件环。事件环保证了Node.js可以高效准确的运行而不会紊乱。<br><img src="img/aiqianduan/WX20200318-174432@2x.png" alt="wx20200312-142532@2x.png"></li></ul><h4 id="4-路由机制"><a href="#4-路由机制" class="headerlink" title="4. 路由机制"></a>4. 路由机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;); </span><br><span class="line"></span><br><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">// 如果要根据用户访问的不同地址呈现不同显示，此时需要用req的url属性来进行判断</span><br><span class="line">    if(req.url == &quot;/&quot;)&#123;</span><br><span class="line">        res.end(&quot;首页&quot;); </span><br><span class="line">    &#125;else if(req.url == &quot;/music.html&quot;)&#123; // 实际上不存在这个页面，但只要输入这个路径，就会显示下面的内容，甚至路径可以伪装成任何样子</span><br><span class="line">        res.end(&quot;音乐频道&quot;); </span><br><span class="line">    &#125;else if(req.url == &quot;/news&quot;)&#123;</span><br><span class="line">        res.end(&quot;新闻频道&quot;); </span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        res.end(&quot;没有这个页面&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 监听</span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure><blockquote><p>Node.js是没有像Apache那种真实物理文件映射关系的！这叫做顶层路由设计。能够制作顶层路由设计的语言目前比较流行的只有Node.js和Python</p></blockquote><h4 id="5-模块"><a href="#5-模块" class="headerlink" title="5. 模块"></a>5. 模块</h4><p><strong>url模块、path模块、querystring模块</strong></p><blockquote><p>一个完整的URL包括querystring部分(就是GET请求查询字符串)、甚至hash部分。但req.url不包括hash(hash是前端标识，用于解决ajax无法回退等问题，所以在后端不用得到)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 例如：http://127.0.0.1:3000/a.html?id=123#456</span><br><span class="line"></span><br><span class="line">var http = require(&quot;http&quot;); </span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    console.log(req.url); </span><br><span class="line">    // http://127.0.0.1:3000/a.html?id=123</span><br><span class="line">    </span><br><span class="line">    res.end(&quot;&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;).listen(3000, &quot;127.0.0.1&quot;); // 直接写监听也可以，还可以限制访问的ip</span><br></pre></td></tr></table></figure><p>而此时我们想得到querystring中的某一部分(l例如文件名)，如果用正则提炼就太麻烦了，Node.js中提供了内置模块：url、path、querystring它们都可以服务于URL的识别。</p><ul><li><strong>url模块</strong>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 例如：http://127.0.0.1:3000/a.html?id=123#456</span><br><span class="line"></span><br><span class="line">var http = require(&quot;http&quot;); </span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    // 将URL的字符串转为JSON对象</span><br><span class="line">    var urlJson = url.parse(req.url);</span><br><span class="line">    console.log(urlJson);</span><br><span class="line">    res.end(&quot;&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;).listen(3000, &quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure></li></ul><p>此时url的parse方法会将地址整理为一个对象，但无法正确识别protocol(协议)、host(主机名)、port(端口号)等等。在Linux系统下可以完全识别。<br><img src="img/aiqianduan/WX20200318-174448@2x.png" alt="wx20200312-235536@2x.png"><br>当有多个参数时，用url.parse(req.url, true)形成对象，方便存入数据库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 例如：http://127.0.0.1:3000/a.html?id=123#456</span><br><span class="line"></span><br><span class="line">var http = require(&quot;http&quot;); </span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    // 将URL的字符串转为JSON对象</span><br><span class="line">    var urlJson = url.parse(req.url, true); // 增加true</span><br><span class="line">    console.log(urlJson);</span><br><span class="line">    res.end(&quot;&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;).listen(3000, &quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure></p><p><img src="img/aiqianduan/WX20200318-174502@2x.png" alt="wx20200313-001127@2x.png"></p><ul><li><p><strong>path模块</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 例如：http://127.0.0.1:3000/a.html?id=123#456</span><br><span class="line"></span><br><span class="line">var http = require(&quot;http&quot;); </span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    // 将URL的字符串转为JSON对象</span><br><span class="line">    var urlJson = url.parse(req.url, true); // 增加true</span><br><span class="line">    // 得到文件路径</span><br><span class="line">    var pathName = urlJson.pathname;</span><br><span class="line">    // 得到拓展名</span><br><span class="line">    var extName = path.extname(pathName);</span><br><span class="line">    res.end(&quot;&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;).listen(3000, &quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure></li><li><p><strong>querystring模块</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 例如：http://127.0.0.1:3000/a.html?id=123#456</span><br><span class="line"></span><br><span class="line">var http = require(&quot;http&quot;); </span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line">var querystring = require(&quot;querystring&quot;);</span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    // 将URL的字符串转为JSON对象</span><br><span class="line">    var urlJson = url.parse(req.url);</span><br><span class="line">    // 得到查询字符串</span><br><span class="line">    var qs = urlJson.query;</span><br><span class="line">    // 转为查询对象，和url.parse加上true非常类似</span><br><span class="line">    var qsJson = querystring.parse(qs);</span><br><span class="line">    res.end(&quot;&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;).listen(3000, &quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>小项目：静态资源服务器 - 创建一个文件夹myweb，我们的程序能够自动为里面的文件、图片、css、js加上路由</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;); </span><br><span class="line">var fs = require(&quot;fs&quot;); </span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line">var querystring = require(&quot;querystring&quot;);</span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    // 得到用户想要读取什么文件(输入的网址)</span><br><span class="line">    var pathName = url.parse(req.url).pathname;</span><br><span class="line">    // 真的去读取这个文件(在myweb里找到这个文件并呈现)</span><br><span class="line">    fs.readFile(&quot;./myweb/&quot; + pathName, function(err,data)&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            res.end(&quot;没有这个文件&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        res.end(data);</span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;).listen(3000, &quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure><p>至此，静态资源服务器的框架已经完备，但还有几个点不够完善，比如下行文件中没有文件类型，所以借助<a href="https://www.w3school.com.cn/media/media_mimeref.asp" target="_blank" rel="noopener">++mime类型++</a>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;); </span><br><span class="line">var fs = require(&quot;fs&quot;); </span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line">var querystring = require(&quot;querystring&quot;);</span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    // 得到用户想要读取什么文件(输入的网址)</span><br><span class="line">    var pathName = url.parse(req.url).pathname;</span><br><span class="line">    // 得到拓展名</span><br><span class="line">    var extName = path.extname(pathName);</span><br><span class="line">    // 准备一个映射关系对</span><br><span class="line">    var mime = &#123;</span><br><span class="line">        &quot;.jpg&quot; : &quot;image/jpeg&quot;,</span><br><span class="line">        &quot;.jpeg&quot; : &quot;image/jpeg&quot;,</span><br><span class="line">        &quot;.gif&quot; : &quot;image/gif&quot;,</span><br><span class="line">        &quot;.png&quot; : &quot;image/png&quot;,</span><br><span class="line">        &quot;.html&quot; : &quot;text/html;chartset=UTF-8&quot;,</span><br><span class="line">        &quot;.css&quot; : &quot;text/css&quot;,</span><br><span class="line">        &quot;.js&quot; : &quot;application/x-javascript&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 真的去读取这个文件(在myweb里找到这个文件并呈现)</span><br><span class="line">    fs.readFile(&quot;./myweb/&quot; + pathName, function(err,data)&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            res.end(&quot;没有这个文件&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 检查是否属于已有的mime类型</span><br><span class="line">        if(mime.hasOwnProperty(extName))&#123;</span><br><span class="line">            res.setHeader(&quot;content-type&quot;, mime[extName]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.end(data);</span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;).listen(3000, &quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure></p><p>第二个问题：不能自动识别index文件。比如用户输入：<a href="http://127.0.0.1:3000/b" target="_blank" rel="noopener">http://127.0.0.1:3000/b</a> 意思是要读取b文件夹中的index.html！解决思路就是如果用户输入了一个URL不存在拓展名，则自动补全/index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;); </span><br><span class="line">var fs = require(&quot;fs&quot;); </span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line">var querystring = require(&quot;querystring&quot;);</span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    // 得到用户想要读取什么文件(输入的网址)</span><br><span class="line">    var pathName = url.parse(req.url).pathname;</span><br><span class="line">    // 得到拓展名</span><br><span class="line">    var extName = path.extname(pathName);</span><br><span class="line">    // 如果URL没有拓展名，则表示是文件夹，此时自动补全/index.html</span><br><span class="line">    if(!extName)&#123;</span><br><span class="line">        /* </span><br><span class="line">        此处还有问题！如果网址不是以/结尾，此时会造成浏览器识别文件路径层次有问题！</span><br><span class="line">        比如：</span><br><span class="line">        http://127.0.0.1:3000/a 和</span><br><span class="line">        http://127.0.0.1:3000/a/ 不一样！</span><br><span class="line">        对于同样一张图片，前者认为是同级目录下的图片，后者认为是a文件夹下的图片！所以要再次判断是否结尾是/，不是的话就需要重定向</span><br><span class="line">        */</span><br><span class="line">        if(pathName.substr(-1) != &quot;/&quot;)&#123;</span><br><span class="line">            res.writeHead(302, &#123; &quot;Location&quot; : pathName + &quot;/&quot; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pathName += &quot;/index.html&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 准备一个映射关系对</span><br><span class="line">    var mime = &#123;</span><br><span class="line">        &quot;.jpg&quot; : &quot;image/jpeg&quot;,</span><br><span class="line">        &quot;.jpeg&quot; : &quot;image/jpeg&quot;,</span><br><span class="line">        &quot;.gif&quot; : &quot;image/gif&quot;,</span><br><span class="line">        &quot;.png&quot; : &quot;image/png&quot;,</span><br><span class="line">        &quot;.html&quot; : &quot;text/html;chartset=UTF-8&quot;,</span><br><span class="line">        &quot;.css&quot; : &quot;text/css&quot;,</span><br><span class="line">        &quot;.js&quot; : &quot;application/x-javascript&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 真的去读取这个文件(在myweb里找到这个文件并呈现)</span><br><span class="line">    fs.readFile(&quot;./myweb/&quot; + pathName, function(err,data)&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            res.end(&quot;没有这个文件&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 检查是否属于已有的mime类型</span><br><span class="line">        if(mime.hasOwnProperty(extName))&#123;</span><br><span class="line">            res.setHeader(&quot;content-type&quot;, mime[extName]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.end(data);</span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;).listen(3000, &quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure></p><p>还有一个问题，就是304状态码(not modified)。当文件没有改变时，拒绝传输文件！也就是当用户狂点刷新时，其实不发送请求。原理是通过session和cookie保存历史镜像，每次提交时进行比对，如果没有改变则不响应。</p><blockquote><p>小结：<br>1.Node.js中的fs模块、mongdb模块基本上都是异步方法。一定要记住(当做规矩背)，==异步方法不能通过return返回，不能通过等号来接收数据。必须通过回调函数传实参的模式来传输数据。==<br>2.内置模块用require无条件、无路径的引用，是Node.js天生就有的。</p></blockquote><ul><li><strong>自定义模块</strong>：每一个js文件。==Node.js、webpack、seajs等使用CMD(通用模块定义)规范==；Angular、requirejs等使用的是AMD(异步模块定义)规范。</li></ul><blockquote><p>01.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;./test.js&quot;);</span><br><span class="line">console.log(&quot;我是01.js&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>test.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;); </span><br><span class="line">console.log(&quot;我是test.js&quot;);</span><br><span class="line">fs.readFile(&quot;./pig.jpg&quot;, function(err, data)&#123;</span><br><span class="line">    console.log(&quot;图片读取完毕&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在01.js中引用test.js，会先打出：我是test.js，然后再打出：我是01.js，最后打出：图片读取完毕。说明：</p><ul><li>require()谁就会运行谁</li><li>require(“./test.js”);中的”./“不能省略</li><li>require的js文件中如果有异步函数，将不会等待，先执行主文件之后的程序，等异步结束后回调函数会执行。</li><li>如果A引用B，此时Node.js发现B又引用了A，则会阻止这次循环引用。</li></ul><h4 id="6-作用域和暴露"><a href="#6-作用域和暴露" class="headerlink" title="6. 作用域和暴露"></a>6. 作用域和暴露</h4><ul><li>exports暴露：当文件有多个东西对外暴露时，使用这个方法</li></ul><blockquote><p>01.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;./test.js&quot;);</span><br><span class="line">console.log(&quot;我是01.js，我认识a么？&quot; + a);</span><br></pre></td></tr></table></figure><blockquote><p>test.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 100; </span><br><span class="line">console.log(&quot;我是test的a&quot; + a);</span><br></pre></td></tr></table></figure><p>此时将报错，01.js打印出undefined，找不到a，因为==Node.js中每个js都是单独的作用域==(闭包)，和DOM开发不同，浏览器中var一个a此时a会自动成为window对象的属性，此时js文件和js文件可以共享作用域；但是Node.js中每个js文件天生是隔离作用域的，所以想要访问其内部的变量或方法，必须先通过exports.xx = xx暴露出去</p><blockquote><p>01.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var test = require(&quot;./test.js&quot;);</span><br><span class="line">console.log(&quot;我是01.js，我认识a么？&quot; + test.a);</span><br><span class="line">console.log(&quot;我是01.js，我认识b么？&quot; + test.b);</span><br><span class="line"></span><br><span class="line">var result = test.zonghe();</span><br><span class="line">console.log(&quot;总和是&quot; + result);</span><br></pre></td></tr></table></figure><blockquote><p>test.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 100; </span><br><span class="line">var b = 200; </span><br><span class="line"></span><br><span class="line">exports.a = a;</span><br><span class="line">exports.b = b;</span><br><span class="line"></span><br><span class="line">function zonghe()&#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">exports.zonghe = zonghe;</span><br></pre></td></tr></table></figure><ul><li>module.exports暴露：当文件只有一个东西对外暴露时，用这个方法</li></ul><blockquote><p>01.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var People = require(&quot;./People.js&quot;);</span><br><span class="line"></span><br><span class="line">// var xiaoming = new People.People(&quot;小明&quot;,&quot;男&quot;,12);</span><br><span class="line">var xiaoming = new People(&quot;小明&quot;,&quot;男&quot;,12);</span><br><span class="line">xiaoming.sayHello();</span><br></pre></td></tr></table></figure><blockquote><p>People.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function People(name, sex, age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.sayHello = function()&#123;</span><br><span class="line">    console.log(&quot;你好，我叫&quot; + this.name + &quot;我今年&quot; + this.age + &quot;我是&quot; + this.sex + &quot;的&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// exports.People = People; </span><br><span class="line">// 如果这里用这种形式暴露的话，那么01.js中用来接收的People会直接替换exports，所以在使用时才会出现People.People这种很怪的方式</span><br><span class="line"></span><br><span class="line">module.exports = People;</span><br><span class="line">// 使用module.exports时等号右边的东西，将自动传给01.js中用来接收的var People</span><br></pre></td></tr></table></figure><h4 id="7-神奇的node-modules文件夹"><a href="#7-神奇的node-modules文件夹" class="headerlink" title="7. 神奇的node_modules文件夹"></a>7. 神奇的node_modules文件夹</h4><p>如果我们写了一个引用没有”./“，则说明引用的是node_modules文件夹里的东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var People = require(&quot;People.js&quot;);</span><br></pre></td></tr></table></figure></p><blockquote><p>node_modules文件夹只要存在于要引用它的js文件的祖先路径中，就可以直接引用，无视路径层级</p></blockquote><h4 id="8-npm的世界"><a href="#8-npm的世界" class="headerlink" title="8. npm的世界"></a>8. npm的世界</h4><p>Node.js的开发者们希望全世界的程序猿都可以贡献自己的代码，避免重复造轮子，所以主导了一个社区，叫做npm(node package management, node包管理器)  </p><ul><li>npm的使用<br>官网：<a href="https://www.npmjs.com" target="_blank" rel="noopener">https://www.npmjs.com</a><br>淘宝镜像：<a href="http://npm.taobao.org" target="_blank" rel="noopener">http://npm.taobao.org</a><br>我们可以到npm上面直接寻找我们想要的模块，然后直接npm install就可以了</li><li>使用package.json来管理依赖<br>npm有一个创造性的举动，可以让开发者声明自己的项目的全部依赖。在项目目录下创建一个叫做package.json的文件来记录。初次创建项目时，可以在项目文件夹下，通过<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li></ul><p>命令来初始化一个package.json文件，而使用–save命令，在安装依赖的同时，会把依赖写进package.json文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx --save</span><br></pre></td></tr></table></figure></p><p>安装时也可以强制安装某个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx#^1.0.0 --save</span><br></pre></td></tr></table></figure></p><p>关于版本号的常用符号：<br>|符号|对应的版本号含义|<br>|:–|:–|<br>|确数(1.0.2)|确定的某个版本|<br>|&gt;、&gt;=、&lt;、&lt;=|高于/低于…某个版本|<br>|~|大约近似等于某个版本，如果有就一定用这个版本，没有就用最近的|<br>|^|寻找和某个版本兼容的版本，如果有就一定用这个版本，没有就用最近的|<br>|*|匹配任何版本|<br>|laste|寻找最新版本|</p><ul><li>全局安装淘宝镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx -g // 全局安装某个包</span><br></pre></td></tr></table></figure></li></ul><p>一些CLI(命令行程序)、工程化的东西安装在全局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><h4 id="9-GET和POST请求"><a href="#9-GET和POST请求" class="headerlink" title="9. GET和POST请求"></a>9. GET和POST请求</h4><blockquote><p>先安装一个小型服务器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm install serve-static --save</span><br><span class="line">cnpm install finalhandler --save</span><br></pre></td></tr></table></figure><p>然后去<a href="npm.taobao.org">淘宝镜像</a>上根据包名查找对应的API，抄一些用法过来，详见nootbook/get&amp;post</p><ul><li>GET请求：</li></ul><blockquote><p>01.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var finalhandler = require(&apos;finalhandler&apos;)</span><br><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var serveStatic = require(&apos;serve-static&apos;)</span><br><span class="line">var url = require(&quot;url&quot;)</span><br><span class="line">var fs = require(&quot;fs&quot;)</span><br><span class="line"></span><br><span class="line">// 配置静态资源服务器</span><br><span class="line">var serve = serveStatic(&apos;public&apos;, &#123; &apos;index&apos;: [&apos;index.html&apos;, &apos;index.htm&apos;] &#125;)</span><br><span class="line"></span><br><span class="line">// Create server</span><br><span class="line">var server = http.createServer(function onRequest(req, res) &#123;</span><br><span class="line">    // 路由</span><br><span class="line">    var pathName = url.parse(req.url).pathname;</span><br><span class="line">    if (pathName == &quot;/addStudent&quot;) &#123;</span><br><span class="line">        // 拿到GET请求参数，也就是那到地址栏中的东西</span><br><span class="line">        var queryJSON = url.parse(req.url, true).query;</span><br><span class="line">        // 整理数据</span><br><span class="line">        var data = &quot;姓名&quot; + queryJSON.name + &quot;\n&quot;;</span><br><span class="line">        data += &quot;年龄&quot; + queryJSON.age + &quot;\n&quot;;</span><br><span class="line">        data += &quot;性别&quot; + queryJSON.sex + &quot;\n&quot;;</span><br><span class="line">        // 写入文件</span><br><span class="line">        fs.writeFile(&quot;./student_data/&quot; + queryJSON.name + &quot;.txt&quot;, data, function(err, data) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                res.end(&quot;cuowu&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.end(&quot;chenggong&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        return; </span><br><span class="line">        // 注意必须要加return，不然会报404错误！是由于不返回的话会再次匹配静态资源造成的</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用静态资源，将public文件夹下的内容静态化出来。这个要放在下面。</span><br><span class="line">    serve(req, res, finalhandler(req, res));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Listen</span><br><span class="line">server.listen(3000)</span><br><span class="line">console.log(&quot;服务器已经运行在3000端口&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>public/index.html</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;性别：</span><br><span class="line">        &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; /&gt;男&lt;/label&gt;</span><br><span class="line">        &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女&lt;/label&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;按我发出GET请求&quot; id=&quot;btn1&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;按我发出POST请求&quot; id=&quot;btn2&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        $(&quot;#btn1&quot;).click(function() &#123;</span><br><span class="line">            // 读取表单</span><br><span class="line">            var name = $(&quot;input[name=name]&quot;).val();</span><br><span class="line">            var age = $(&quot;input[name=age]&quot;).val();</span><br><span class="line">            var sex = $(&quot;input[name=sex]&quot;).val();</span><br><span class="line"></span><br><span class="line">            // 发送请求</span><br><span class="line">            $.get(&quot;/addStudent&quot;, &#123;</span><br><span class="line">                name : name,</span><br><span class="line">                age : age,</span><br><span class="line">                sex : sex</span><br><span class="line">            &#125;, function(data) &#123;</span><br><span class="line">                if (data == &quot;chenggong&quot;) &#123;</span><br><span class="line">                    alert(&quot;恭喜，学生已成功添加！&quot;)</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    alert(&quot;对不起，服务器错误！&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        $(&quot;#btn2&quot;).click(function () &#123;</span><br><span class="line">                // 读取表单</span><br><span class="line">                var name = $(&quot;input[name=name]&quot;).val();</span><br><span class="line">                var age = $(&quot;input[name=age]&quot;).val();</span><br><span class="line">                var sex = $(&quot;input[name=sex]&quot;).val();</span><br><span class="line"></span><br><span class="line">                // 发送请求</span><br><span class="line">                $.post(&quot;/addStudent&quot;, &#123;</span><br><span class="line">                    name: name,</span><br><span class="line">                    age: age,</span><br><span class="line">                    sex: sex</span><br><span class="line">                &#125;, function (data) &#123;</span><br><span class="line">                    if (data == &quot;chenggong&quot;) &#123;</span><br><span class="line">                        alert(&quot;恭喜，学生已成功添加！&quot;)</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        alert(&quot;对不起，服务器错误！&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>POST请求</li></ul><blockquote><p>02.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    演示POST请求的获得</span><br><span class="line">*/</span><br><span class="line">var finalhandler = require(&apos;finalhandler&apos;)</span><br><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var serveStatic = require(&apos;serve-static&apos;)</span><br><span class="line">var url = require(&quot;url&quot;)</span><br><span class="line">var fs = require(&quot;fs&quot;)</span><br><span class="line">var querystring = require(&quot;querystring&quot;)</span><br><span class="line"></span><br><span class="line">// 配置静态资源服务器</span><br><span class="line">var serve = serveStatic(&apos;public&apos;, &#123; &apos;index&apos;: [&apos;index.html&apos;, &apos;index.htm&apos;] &#125;)</span><br><span class="line"></span><br><span class="line">// Create server</span><br><span class="line">var server = http.createServer(function onRequest(req, res) &#123;</span><br><span class="line">    // 路由</span><br><span class="line">    var pathName = url.parse(req.url).pathname;</span><br><span class="line">    if (pathName == &quot;/addStudent&quot;) &#123;</span><br><span class="line">        // 定义了一个post变量，用于暂存请求体的信息</span><br><span class="line">        var content = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">        // post请求经常会很长，此时会分段传送，大约每段800k左右一个HTTP报文段</span><br><span class="line">        // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中</span><br><span class="line">        req.on(&apos;data&apos;, function (chunk) &#123;</span><br><span class="line">            // 将段落合并</span><br><span class="line">            content += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 当所有数据发送完毕后，会触发end事件，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。</span><br><span class="line">        req.on(&apos;end&apos;, function () &#123;</span><br><span class="line">            content = querystring.parse(content);</span><br><span class="line"></span><br><span class="line">            // 整理数据</span><br><span class="line">            var data = &quot;姓名&quot; + content.name + &quot;\n&quot;;</span><br><span class="line">            data += &quot;年龄&quot; + content.age + &quot;\n&quot;;</span><br><span class="line">            data += &quot;性别&quot; + content.sex + &quot;\n&quot;;</span><br><span class="line">            // 写入文件</span><br><span class="line">            fs.writeFile(&quot;./student_data/&quot; + content.name + &quot;.txt&quot;, data, function (err, data) &#123;</span><br><span class="line">                if (err) &#123;</span><br><span class="line">                    res.end(&quot;cuowu&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    res.end(&quot;chenggong&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            res.end(&quot;chengogng&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用静态资源。这个要放在下面。</span><br><span class="line">    serve(req, res, finalhandler(req, res));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Listen</span><br><span class="line">server.listen(3000)</span><br><span class="line">console.log(&quot;服务器已经运行在3000端口&quot;);</span><br></pre></td></tr></table></figure><h4 id="10-formidable模块：npm上可以下载一个formidable的模块，用来处理post请求。甚至可以处理图片、zip文件等的上传。"><a href="#10-formidable模块：npm上可以下载一个formidable的模块，用来处理post请求。甚至可以处理图片、zip文件等的上传。" class="headerlink" title="10. formidable模块：npm上可以下载一个formidable的模块，用来处理post请求。甚至可以处理图片、zip文件等的上传。"></a>10. formidable模块：npm上可以下载一个formidable的模块，用来处理post请求。甚至可以处理图片、zip文件等的上传。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install formidable --save // 安装依赖</span><br></pre></td></tr></table></figure><p>具体代码详见03.js和upload.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    演示POST请求通过formidable模块来处理参数</span><br><span class="line">*/</span><br><span class="line">var finalhandler = require(&apos;finalhandler&apos;)</span><br><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var serveStatic = require(&apos;serve-static&apos;)</span><br><span class="line">var url = require(&quot;url&quot;)</span><br><span class="line">var fs = require(&quot;fs&quot;)</span><br><span class="line">var querystring = require(&quot;querystring&quot;)</span><br><span class="line">const formidable = require(&apos;formidable&apos;)</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">// 配置静态资源服务器</span><br><span class="line">var serve = serveStatic(&apos;public&apos;, &#123;</span><br><span class="line">    &apos;index&apos;: [&apos;index.html&apos;, &apos;index.htm&apos;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Create server</span><br><span class="line">var server = http.createServer(function onRequest(req, res) &#123;</span><br><span class="line">    // 路由</span><br><span class="line">    var pathName = url.parse(req.url).pathname;</span><br><span class="line">    </span><br><span class="line">    if (pathName == &quot;/shangchuan&quot;) &#123;</span><br><span class="line">        // 照抄npm.taobao.org上的API</span><br><span class="line">        const form = formidable(&#123;</span><br><span class="line">            multiples: true</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 设置上传的文件存放在哪里</span><br><span class="line">        form.uploadDir = &quot;./uploads&quot;</span><br><span class="line"></span><br><span class="line">        form.parse(req, (err, fields, files) =&gt; &#123;</span><br><span class="line">            // fields 表示普通控件</span><br><span class="line">            // files  表示文件控件</span><br><span class="line"></span><br><span class="line">            // 检测是否有文件</span><br><span class="line">            if (!files.touxiang) &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            // 检测是否有上传文件</span><br><span class="line">            if (!files.touxiang.name) &#123;</span><br><span class="line">                res.end(&quot;请选择文件&quot;)</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            // 得到拓展名</span><br><span class="line">            var extname = path.extname(files.touxiang.name);</span><br><span class="line">            // 为上传的文件加上拓展名</span><br><span class="line">            fs.rename(files.touxiang.path, files.touxiang.path + extname, function() &#123;</span><br><span class="line">                res.end(&quot;上传成功&quot;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用静态资源。这个要放在下面。</span><br><span class="line">    serve(req, res, finalhandler(req, res));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Listen</span><br><span class="line">server.listen(3000)</span><br><span class="line">console.log(&quot;服务器已经运行在3000端口&quot;);</span><br></pre></td></tr></table></figure></p><p>待补充(两个大包)</p><h4 id="11-Express-js框架："><a href="#11-Express-js框架：" class="headerlink" title="11. Express.js框架："></a>11. Express.js框架：</h4><blockquote><p>解决了哪些问题</p><ul><li>路由不方便制作，尤其是正则表达式路由</li><li>静态资源服务不方便</li><li>页面呈递不方便，没有模板引擎</li></ul></blockquote><blockquote><p>官网：<a href="www.expressjs.com.cn">www.expressjs.com.cn</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install express --save</span><br></pre></td></tr></table></figure><p>基本使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var app = express();</span><br><span class="line">// 中间件(注意顺序)</span><br><span class="line">app.get(&quot;/&quot;, function()&#123;</span><br><span class="line">    res.send(&quot;我是首页&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&quot;/music&quot;, function()&#123;</span><br><span class="line">    res.send(&quot;音乐频道&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&quot;/news&quot;, function()&#123;</span><br><span class="line">    res.send(&quot;新闻频道&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&quot;/student/:xuehao&quot;, function()&#123;</span><br><span class="line">    if(/^[\d]&#123;6&#125;$/.test(req.params.xuehao))&#123;</span><br><span class="line">        res.send(&quot;学生频道，学号&quot; + req.params.xuehao);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.send(&quot;学号有误，应该是6位数字&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&quot;/student/:123&quot;, function()&#123;</span><br><span class="line">    res.send(&quot;123是班长&quot; + req.params.xuehao);</span><br><span class="line">    // 这个中间件将不会被匹配到，因为上面匹配到了学号就不会再往下走了</span><br><span class="line">&#125;)</span><br><span class="line">// 静态化public文件夹，无论get还是post都能使用</span><br><span class="line">app.use(express.static(&quot;./public&quot;));</span><br><span class="line">// 将public文件夹中的东西映射到jingtai文件夹中(访问路径也变为/jingtai/xxx)</span><br><span class="line">app.use(&quot;./jingtai&quot;, express.static(&quot;./public&quot;));</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure></p><blockquote><p>中间件特点：</p><ul><li>输出使用res.send()而不是res.end()</li><li>自动使用pathname与/news进行比较，也就是说会自动过滤掉querystring、hash等等</li><li>可以用：来引导一个变量，此时特别方便做一个正则的路由，并用req.params.xxx获取</li></ul></blockquote><blockquote><p>需求：当访问 / 时，其实真正想访问的页面是public/haha.html</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">app.get(&quot;/&quot;, function()&#123;</span><br><span class="line">    res.sendFile(__dirname + &quot;/public/haha.html&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>==res常用的函数是send和sendFile。sendFile表示发送一个页面给用户。注意sendFile必须使用绝对路径当做参数，而__dirname表示当前这个js文件的绝对路径==</p><h4 id="12-模板引擎：express可以象PHP一样使用后台语言模板，此时最好用的模板引擎叫做ejs模板引擎。"><a href="#12-模板引擎：express可以象PHP一样使用后台语言模板，此时最好用的模板引擎叫做ejs模板引擎。" class="headerlink" title="12. 模板引擎：express可以象PHP一样使用后台语言模板，此时最好用的模板引擎叫做ejs模板引擎。"></a>12. 模板引擎：express可以象PHP一样使用后台语言模板，此时最好用的模板引擎叫做ejs模板引擎。</h4><p>API：<a href="https://npm.taobao.org/package/ejs" target="_blank" rel="noopener">https://npm.taobao.org/package/ejs</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install ejs --save</span><br></pre></td></tr></table></figure></p><p>基本使用方法：</p><blockquote><p>01.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">// 设置默认的模板引擎，此时express将帮你引入ejs，所以一定要提前装好依赖</span><br><span class="line">app.set(&quot;view engine&quot;, &quot;ejs&quot;);</span><br><span class="line"></span><br><span class="line">app.get(&quot;/&quot;, function()&#123;</span><br><span class="line">    res.render(&quot;shouye&quot;,&#123;</span><br><span class="line">        &quot;dongxi&quot; : &quot;八个手机&quot;,</span><br><span class="line">        &quot;qian&quot; : 1000 * 8</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure><p>此时当用户访问 / 的时候，会自动使用views文件夹里的shouye.ejs文件当做模板。字典就是后面传入的json。</p><blockquote><p>views/shouye.ejs</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;我买了&lt;% dongxi %&gt;，花了&lt;% qian %&gt;元&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>注意：ejs就是html，写法完全一样！</p><h4 id="13-MVC设计模式："><a href="#13-MVC设计模式：" class="headerlink" title="13. MVC设计模式："></a>13. MVC设计模式：</h4><p>MVC是一种使用Model(模型)、View(视图)、Controller(控制器)设计创建Web应用程序的模式。</p><ul><li>Model(模型)是应用程序中处理应用程序数据逻辑的部分，通常模型对象负责在数据库中存取数据。</li><li>View(视图)是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的。</li><li>Controller(控制器)是应用程序中处理用户交互的部分，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(Controller) --&gt;B(Model)</span><br><span class="line">B(Model) --&gt;A(Controller)</span><br><span class="line">A(Controller) --&gt;C(View)</span><br></pre></td></tr></table></figure></li></ul><p>因数计算器和点餐系统代码详见作业</p><h4 id="14-MongoDB芒果数据库"><a href="#14-MongoDB芒果数据库" class="headerlink" title="14. MongoDB芒果数据库"></a>14. MongoDB芒果数据库</h4><blockquote><p>NoSQL简介</p></blockquote><ul><li>SQL就是Structor Query Language(结构化语言)。MySQL、Oracle、SQL Server数据库都是SQL数据库，在大数据时代有些场景使用它们显得太笨重，因为SQL有一个非常大的缺点，就是限制字段：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如现在数据库中已经有10万条数据了(在今天10万条都不算大数据)，如果想从下一条数据开始增加字段，此时之前的10万条数据都需要被更改！表的字段是不能自由更改的，不能某一个条目有一些字段，另外的条目没有！</span><br></pre></td></tr></table></figure></li></ul><p>而SQL的优势在于能够轻松执行复杂查找，例如主从关系查找等。但在大数据时代SQL的优势在衰减(基本都是简单查询)，而缺点在被放大。所以此时NoSQL(Not Only SQL)这种==非关系型数据库==应运而生。</p><p>NoSQL中没有字段的概念，每个条目可以自由设置字段。</p><blockquote><p>MongoDB安装与配置详见踩坑之各种报错篇，创建好数据库后就可以进行各种指令操作数据库了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; use student</span><br><span class="line">// 创建名为student的数据库，此时可以用db来代表这个数据库</span><br><span class="line"></span><br><span class="line">db.banji01.insert(&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:12&#125;)</span><br><span class="line">// 在student数据库(此处用db代表)中创建banji01集合(表)，并插入一条数据(数据用json格式)</span><br><span class="line"></span><br><span class="line">db.banji01.find();</span><br><span class="line">// 查找banji01表中的数据(会为你填上随机数的id)</span><br><span class="line"></span><br><span class="line">db.banji01.insert(&#123;&quot;name&quot;:&quot;小红&quot;,&quot;age&quot;:12&#125;)</span><br><span class="line">db.banji01.insert(&#123;&quot;name&quot;:&quot;小强&quot;,&quot;age&quot;:11&#125;)</span><br><span class="line"></span><br><span class="line">db.banji01.find(&#123;&quot;age&quot;:12&#125;);</span><br><span class="line">// 有条件查找</span><br></pre></td></tr></table></figure><h4 id="15-Node-js和MongoDB的连接"><a href="#15-Node-js和MongoDB的连接" class="headerlink" title="15. Node.js和MongoDB的连接"></a>15. Node.js和MongoDB的连接</h4><p><a href="https://docs.mongodb.com/ecosystem/drivers/node/" target="_blank" rel="noopener">API</a></p><ul><li>先安装依赖<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install mongodb --save</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>文档与集合的关系：</p><ul><li>文档<br><img src="img/aiqianduan/WX20200318-174539@2x.png" alt="1584430515111.jpg"></li><li>集合<br><img src="img/aiqianduan/WX20200318-174550@2x.png" alt="wx20200317-153442@2x.png"></li></ul></blockquote><p>在REPL环境中最常用的命令语句，除了上面用到的，还有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; use student // 使用student数据库，没有就创建</span><br><span class="line">&gt; show dbs // 显示所有数据库列表</span><br><span class="line">&gt; show collections // 显示当前数据库的所有集合列表</span><br></pre></td></tr></table></figure></p><blockquote><p>增删改查：<a href="http://mongodb.github.io/node-mongodb-native/3.5/tutorials/crud/" target="_blank" rel="noopener">API</a></p></blockquote><ul><li><p>增(mongodb/01.js)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">const MongoClient = require(&apos;mongodb&apos;).MongoClient;</span><br><span class="line">// const assert = require(&apos;assert&apos;); // 断言</span><br><span class="line"></span><br><span class="line">// 连接的url</span><br><span class="line">const url = &apos;mongodb://localhost:27017&apos;;</span><br><span class="line"></span><br><span class="line">// 数据库名</span><br><span class="line">const dbName = &apos;student&apos;;</span><br><span class="line"></span><br><span class="line">// 建立一个新连接</span><br><span class="line">const client = new MongoClient(url);</span><br><span class="line"></span><br><span class="line">// 用connect方法连接服务</span><br><span class="line">client.connect(function (err, client) &#123;</span><br><span class="line">    // assert.equal(null, err); // 断言验证</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        console.log(&quot;数据库连接失败！&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;数据库连接成功&quot;);</span><br><span class="line"></span><br><span class="line">    // 用db代替数据库名</span><br><span class="line">    const db = client.db(dbName);</span><br><span class="line"></span><br><span class="line">    // 在指定的表内插入一条数据</span><br><span class="line">    db.collection(&apos;banji01&apos;).insertOne(&#123;</span><br><span class="line">        &quot;name&quot;: &quot;刘备&quot;,</span><br><span class="line">        &quot;age&quot; : 12</span><br><span class="line">    &#125;, function (err, r) &#123;</span><br><span class="line">        // assert.equal(null, err); // 断言验证</span><br><span class="line">        // assert.equal(1, r.insertedCount); // 断言验证</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            console.log(&quot;数据插入失败！&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;成功插入了&quot; + r.insertedCount + &quot;条数据&quot;)</span><br><span class="line"></span><br><span class="line">        // 插入多条数据的方法</span><br><span class="line">        db.collection(&apos;banji01&apos;).insertMany([&#123; a: 2 &#125;, &#123; a: 3 &#125;], function (err, r) &#123;</span><br><span class="line">            assert.equal(null, err);</span><br><span class="line">            assert.equal(2, r.insertedCount);</span><br><span class="line">            // 关闭数据库</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>删</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const MongoClient = require(&apos;mongodb&apos;).MongoClient;</span><br><span class="line"></span><br><span class="line">const url = &apos;mongodb://localhost:27017&apos;;</span><br><span class="line"></span><br><span class="line">const dbName = &apos;myproject&apos;;</span><br><span class="line"></span><br><span class="line">const client = new MongoClient(url);</span><br><span class="line"></span><br><span class="line">client.connect(function(err, client) &#123;</span><br><span class="line">  assert.equal(null, err);</span><br><span class="line">  console.log(&quot;Connected correctly to server&quot;);</span><br><span class="line"></span><br><span class="line">  const db = client.db(dbName);</span><br><span class="line"></span><br><span class="line">  const col = db.collection(&apos;removes&apos;);</span><br><span class="line">  // Insert multiple documents</span><br><span class="line">  col.insertMany([&#123;a:1&#125;, &#123;a:2&#125;, &#123;a:2&#125;], function(err, r) &#123;</span><br><span class="line">    assert.equal(null, err);</span><br><span class="line">    assert.equal(3, r.insertedCount);</span><br><span class="line"></span><br><span class="line">    // Remove a single document</span><br><span class="line">    col.deleteOne(&#123;a:1&#125;, function(err, r) &#123;</span><br><span class="line">      assert.equal(null, err);</span><br><span class="line">      assert.equal(1, r.deletedCount);</span><br><span class="line"></span><br><span class="line">      // Update multiple documents</span><br><span class="line">      col.deleteMany(&#123;a:2&#125;, function(err, r) &#123;</span><br><span class="line">        assert.equal(null, err);</span><br><span class="line">        assert.equal(2, r.deletedCount);</span><br><span class="line">        client.close();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>查 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&apos;banji01&apos;).find(&#123;&quot;name&quot;:&quot;小明&quot;&#125;).toArray(</span><br><span class="line">// 注意与其他的不同，这里find的结果要先转成数组</span><br><span class="line">    function(err,results)&#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            console.log(&quot;数据查询失败！&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(results) // 打印出查询到的条目</span><br><span class="line">        db.close()</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>多个查询条件时，例如寻找姓名是小明且年龄为12的学生，用“ ，”隔开。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&apos;banji01&apos;).find(&#123;</span><br><span class="line">    &quot;name&quot;:&quot;小明&quot;,</span><br><span class="line">    &quot;age&quot;:12</span><br><span class="line">&#125;).toArray(</span><br><span class="line">    function(err,results)&#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            console.log(&quot;数据查询失败！&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(results) // 打印出查询到的条目</span><br><span class="line">        db.close()</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>查询条件中的大于、小于条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&apos;banji01&apos;).find(&#123;</span><br><span class="line">    &quot;age&quot;:&#123;$gt : 12&#125; // &#123;$gt : 12&#125;表示大于12</span><br><span class="line">    //&quot;age&quot;:&#123;$lt : 12&#125; // &#123;$lt : 12&#125;表示大于12</span><br><span class="line">&#125;).toArray(</span><br><span class="line">    function(err,results)&#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            console.log(&quot;数据查询失败！&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(results) // 打印出查询到的条目</span><br><span class="line">        db.close()</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>或逻辑：用$or来引导一个数组，里面是或的条件。例如寻找年龄大于12岁的男生或者年龄小于11岁的女生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&apos;banji01&apos;).find(&#123;</span><br><span class="line">    &#123;$or : [</span><br><span class="line">        &#123; &quot;age&quot;:&#123;$gt:12&#125; , &quot;sex&quot;: &quot;男&quot;&#125;,</span><br><span class="line">        &#123; &quot;age&quot;:&#123;$lt:11&#125; , &quot;sex&quot;: &quot;女&quot;&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">&#125;).toArray(</span><br><span class="line">    function(err,results)&#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            console.log(&quot;数据查询失败！&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(results) // 打印出查询到的条目</span><br><span class="line">        db.close()</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ul><li>改：分为增量改和彻底改两种。彻底改用处不大，就是把一条数据完全改成另一条数据，此举危险！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&apos;banji01&apos;).updateOne(</span><br><span class="line">    &#123;&quot;name&quot;: &quot;刘备&quot;&#125;,</span><br><span class="line">    &#123;&quot;age&quot; : 12&#125;</span><br><span class="line">, function (err, r) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        console.log(&quot;数据修改失败！&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;成功&quot;)</span><br><span class="line">    // 此时&quot;name&quot;: &quot;刘备&quot;会被替换成&quot;age&quot; : 12</span><br><span class="line">    // &quot;name&quot;: &quot;刘备&quot;这个属性就没了！</span><br><span class="line">    client.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>增量改：用$set引导<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&apos;banji01&apos;).updateOne(</span><br><span class="line">    &#123;&quot;name&quot;: &quot;刘备&quot;&#125;,</span><br><span class="line">    &#123;$set:&#123;&quot;age&quot; : 12&#125;&#125;</span><br><span class="line">, function (err, r) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        console.log(&quot;数据修改失败！&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;成功&quot;)</span><br><span class="line">    // 此时刘备的age会被替换成12！</span><br><span class="line">    client.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="16-MongoDB"><a href="#16-MongoDB" class="headerlink" title="16. MongoDB"></a>16. MongoDB</h4><p>数据库 = 存储东西 + 数据库操作API。</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>vue提供了一种“引包法”，初学者在这个模式下学习基本语法，不需要webpack，不需要CMD打包</p><h3 id="二、启动"><a href="#二、启动" class="headerlink" title="二、启动"></a>二、启动</h3><blockquote><p>vue的包：<a href="https://cn.vuejs.org/js/vue.js" target="_blank" rel="noopener">https://cn.vuejs.org/js/vue.js</a>，使用方式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;1 + 1&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;./jslib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el : &quot;#app&quot;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>这里是唯一的一次书写new运算符。这是vue的语法，因为vue是一个构造函数，注意它并不是组件的构造函数，就是启动语法而已。</p><blockquote><p>React中任何一个组件都是一个class(类)，并且这个类继承于React.Component。当你放标签的时候，相当于实例化了这个类。<br>Vue也是一样，任何一个组件也是一个类。但Vue有一个非常大的特点：++语法隐藏底层细节++</p></blockquote><h3 id="三、MVVM特性"><a href="#三、MVVM特性" class="headerlink" title="三、MVVM特性"></a>三、MVVM特性</h3><ol><li><p>清单式语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;a&#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;button @click=&quot;add()&quot;&gt;按我+1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;./jslib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            // 运行点</span><br><span class="line">            el : &quot;#app&quot;,</span><br><span class="line">            // 数据</span><br><span class="line">            data: &#123;</span><br><span class="line">                a : 100</span><br><span class="line">            &#125;</span><br><span class="line">            // 方法</span><br><span class="line">            methods: &#123;</span><br><span class="line">                add()&#123;</span><br><span class="line">                    this.a++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>双向绑定机理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var obj = &#123;</span><br><span class="line">            a : 8</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Object.defineProperties(obj, &#123;</span><br><span class="line">            &quot;a&quot; : &#123;</span><br><span class="line">                set()&#123;</span><br><span class="line">                    alert(&quot;改了！快通知视图跟着变！&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="四、指令"><a href="#四、指令" class="headerlink" title="四、指令"></a>四、指令</h3><blockquote><p>指令，即标签身上的属性，只是这些属性有特殊性、功能性</p></blockquote><ol><li>v-if和v-show</li></ol><ul><li>v-if决定元素是否上树</li><li>v-show决定元素是否显示</li></ul><blockquote><p>如果需要触发组件的生命周期钩子函数，此时让组件携带v-if，反之用v-show</p></blockquote><ol><li>v-for：用来实现循环某个节点，循环节点必须绑key<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item, index) in arr&quot; v-bind:key=&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123; index &#125;&#125; - &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li></ol><p>特别的，可以循环自然数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=&quot;item in 5&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>99乘法表</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr v-for=&quot;i in 9&quot;&gt;</span><br><span class="line">        &lt;td v-for=&quot;j in 9&quot;&gt;</span><br><span class="line">            &lt;span v-show=&quot;i&gt;=j&quot;&gt;</span><br><span class="line">                &#123;&#123; i &#125;&#125; * &#123;&#123; j &#125;&#125; = &#123;&#123; i*j &#125;&#125;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><ol><li>v-bind(==重难点==)</li></ol><blockquote><p>v-bind指令可以让任何W3C属性变“动态”。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;input tyoe=&quot;text&quot; v-bind:value=&quot;a&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;./jslib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el : &quot;#app&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                a : 100</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：v-bind:xxx=”…” 冒号里面已经是动态的了，所以在里面的写法要和js语法保持一致！特别注意连字符！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input tyoe=&quot;text&quot; v-bind:value=&quot;a&quot; /&gt;</span><br><span class="line">&lt;input tyoe=&quot;text&quot; v-bind:value=&quot;3+5&quot; /&gt;</span><br><span class="line">&lt;input tyoe=&quot;text&quot; v-bind:value=&quot;&apos;./images/&apos; + a + &apos;.jpg&apos;&quot; /&gt;</span><br><span class="line">&lt;input tyoe=&quot;text&quot; v-bind:value=&quot;`./images/$&#123;a&#125;.jpg`&quot; /&gt;</span><br></pre></td></tr></table></figure><ol><li>v-on：事件监听 </li><li>v-model：双向绑定</li></ol><blockquote><p>调色板案例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;调色板&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .box&#123;width: 200px; height: 200px; border: 1px solid #000;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot; :style=&quot;`background-color:rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;input type=&quot;range&quot; :min=&quot;0&quot; :max=&quot;255&quot; v-model=&quot;r&quot; /&gt;</span><br><span class="line">            &lt;input type=&quot;number&quot; :min=&quot;0&quot; :max=&quot;255&quot; v-model=&quot;r&quot; /&gt;</span><br><span class="line">            &#123;&#123; r &#125;&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;input type=&quot;range&quot; :min=&quot;0&quot; :max=&quot;255&quot; v-model=&quot;g&quot; /&gt;</span><br><span class="line">            &lt;input type=&quot;number&quot; :min=&quot;0&quot; :max=&quot;255&quot; v-model=&quot;g&quot; /&gt;</span><br><span class="line">            &#123;&#123; g &#125;&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;input type=&quot;range&quot; :min=&quot;0&quot; :max=&quot;255&quot; v-model=&quot;b&quot; /&gt;</span><br><span class="line">            &lt;input type=&quot;number&quot; :min=&quot;0&quot; :max=&quot;255&quot; v-model=&quot;b&quot; /&gt;</span><br><span class="line">            &#123;&#123; b &#125;&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;jslib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el : &quot;#app&quot;,</span><br><span class="line">            data : &#123;</span><br><span class="line">                r : 100,</span><br><span class="line">                g : 200,</span><br><span class="line">                b : 123</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol><li>computed和methods</li></ol>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
          <category> 笔记 </category>
          
          <category> 爱前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vue考点</title>
      <link href="/79c7d788.html"/>
      <content type="html"><![CDATA[<p>[toc]</p><h5 id="1-页面中定义一个定时器，在哪个阶段清除？"><a href="#1-页面中定义一个定时器，在哪个阶段清除？" class="headerlink" title="1.页面中定义一个定时器，在哪个阶段清除？"></a>1.页面中定义一个定时器，在哪个阶段清除？</h5><p>答案：在 beforeDestroy 中销毁定时器。<br>① 为什么销毁它：<br>在页面 a 中写了一个定时器，比如每隔一秒钟打印一次 1，当我点击按钮进入页面 b 的时候，会发现定时器依然在执行，这是非常消耗性能的。<br>② 解决方案<br>A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mounted()&#123;</span><br><span class="line"> this.timer = setInterval(()=&gt;&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line"> &#125;,1000)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy()&#123;</span><br><span class="line"> clearInterval(this.timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方案A有两点不好的地方，引用尤大的话来说就是：<br>它需要在这个组件实例中保存这个 timer，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。<br>我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化的清理我们建立的所有东西。  </p><p>方案B（推荐）：该方法是通过$once 这个事件侦听器在定义完定时器之后的位置来清除定时器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mounted()&#123;</span><br><span class="line"> const timer = setInterval(()=&gt;&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line"> &#125;,1000)</span><br><span class="line"> this.$once(&apos;hook:beforeDestroy&apos;,()=&gt;&#123;</span><br><span class="line">  clearInterval(timer)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>官网参考链接:<a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/components-edge-cases.html</a><br><img src="img/aiqianduan/WX20200318-175757@2x.png" alt="1584101009846.jpg"></p><h5 id="2-父组件如何获取子组件的数据，子组件如何获取父组件的数据，父子组件如何传值？"><a href="#2-父组件如何获取子组件的数据，子组件如何获取父组件的数据，父子组件如何传值？" class="headerlink" title="2.父组件如何获取子组件的数据，子组件如何获取父组件的数据，父子组件如何传值？"></a>2.父组件如何获取子组件的数据，子组件如何获取父组件的数据，父子组件如何传值？</h5><p>① 先说，父组件如何主动获取子组件的数据？</p><p>方案 1：$children  </p><p>$children 用来访问子组件实例，要知道一个组件的子组件可能是不唯一的，所以它的返回值是数组。</p><p>现在，我们定义 Header，HelloWorld 两个组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;index&quot;&gt;</span><br><span class="line">    &lt;Header&gt;&lt;/Header&gt;</span><br><span class="line">    &lt;HelloWorld :message=&quot;message&quot;&gt;&lt;/HelloWorld&gt;</span><br><span class="line">    &lt;button @click=&quot;goPro&quot;&gt;跳转&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">mounted()&#123;</span><br><span class="line"> console.log(this.$children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="img/aiqianduan/WX20200318-175757@2x.png" alt="1584101171037.jpg"><br>打印的是一个数组，可以用 foreach 分别得到所需要的的数据</p><p>缺点：<br>无法确定子组件的顺序，也不是响应式的。如果你确切的知道要访问子组件建议使用$refs。</p><p>方案 2 ：$refs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HelloWorld ref=&quot;hello&quot; :message=&quot;message&quot;&gt;&lt;/HelloWorld&gt;</span><br></pre></td></tr></table></figure></p><p>调用 helloworld 子组件的时候直接定义一个 ref，这样就可以通过 this.$refs 获取所需要的的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$refs.hello.属性</span><br><span class="line">this.$refs.hello.方法</span><br></pre></td></tr></table></figure></p><p>② 子组件如何主动获取父组件中的数据？</p><p>通过 ：$parent</p><p>用来访问父组件实例，通常父组件都是唯一确定的，跟children类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$parent.属性</span><br><span class="line">this.$parent.方法</span><br></pre></td></tr></table></figure></p><p>父子组件通信除了以上三种，还有 props 和 attrs</p><p>③ <strong>inheritAttrs</strong></p><p>这是@2.4 新增的属性和接口。inheritAttrs 属性控制子组件 html 属性上是否显示父组件的提供的属性。<br>如果我们将父组件 Index 中的属性 desc、keysword、message 三个数据传递到子组件 HelloWorld 中的话，如下<br>父组件 Index 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HelloWorld ref=&quot;hello&quot; :desc=&quot;desc&quot; :keysword=&quot;keysword&quot; :message=&quot;message&quot;&gt;&lt;/HelloWorld&gt;</span><br></pre></td></tr></table></figure></p><p>子组件：HelloWorld，props 中只接受了 message<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    message: String</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>实际情况，我们只需要 message，那其他两个属性则会被当做普通的 html 元素插在子组件的根元素上。<br>如图<br><img src="img/aiqianduan/WX20200318-175950@2x.png" alt="1584101249511.jpg"><br>这样做会使组件预期功能变得模糊不清，这个时候，在子组件中写入，inheritAttrs：false ，这些没用到的属性便会被去掉，true 的话，就会显示。</p><p>如果，父组件中没被需要的属性，跟子组件本来的属性冲突的时候，则依据父组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HelloWorld ref=&quot;hello&quot; type=&quot;text&quot; :message=&quot;message&quot;&gt;&lt;/HelloWorld&gt;</span><br></pre></td></tr></table></figure></p><p>子组件：HelloWorld<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;number&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>这个时候父组件中 type=“text”，而子组件中 type=”number”,而实际中最后显示的是 type=”text”，这并不是我们想要的，所以只要设置：inheritAttrs：false，type 便会成为 number<br><img src="img/aiqianduan/WX20200318-180230@2x.png" alt="1584101325109.jpg"><br>上述这些没被用到的属性，如何被获取呢？这就用到了$attrs</p><p>③ <strong>$attrs</strong></p><p>作用：可以获取到没有使用的注册属性，如果需要，我们在这也可以往下继续传递。<br>就上上述没有被用到的 desc 和 keysword 就能通过$attrs 获取到。</p><p>通过$attrs 的这个特性可以父组件传递到孙组件，免除父组件传递到子组件，再从子组件传递到孙组件的麻烦</p><p>代码如下 父组件 Index 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;index&quot;&gt;</span><br><span class="line">  &lt;HelloWorld ref=&quot;hello&quot; :desc=&quot;desc&quot; :keysword=&quot;keysword&quot; :message=&quot;message&quot;&gt;&lt;/HelloWorld&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> data()&#123;</span><br><span class="line">  return&#123;</span><br><span class="line">   message:&apos;首页&apos;,</span><br><span class="line">   desc:&apos;首页描述&apos;,</span><br><span class="line">   keysword:&apos;我是关键词key&apos;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>子组件 HelloWorld 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">   &lt;sunzi v-bind=&quot;$attrs&quot;&gt;&lt;/sunzi&gt;</span><br><span class="line">   &lt;button @click=&quot;aa&quot;&gt;获取父组件的数据&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>孙子组件 sunzi 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;header&quot;&gt;</span><br><span class="line">    &#123;&#123;$attrs&#125;&#125;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>可以看出通过 v-bind=”$attrs”将数据传到孙组件中</p><p>除了以上，provide / inject 也适用于 隔代组件通信，尤其是获取祖先组件的数据，非常方便。<br><img src="img/aiqianduan/WX20200318-180252@2x.png" alt="1584101475501.jpg"><br>简单的说，当组件的引入层次过多，我们的子孙组件想要获取祖先组件的资源，那么怎么办呢，总不能一直取父级往上吧，而且这样代码结构容易混乱。这个就是 provide / inject 要干的事情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">&lt;childOne&gt;&lt;/childOne&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import childOne from &apos;../components/test/ChildOne&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Parent&quot;,</span><br><span class="line">    provide: &#123;</span><br><span class="line">      for: &quot;demo&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      childOne</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>在这里我们在父组件中 provide for 这个变量，然后直接设置三个组件（childOne、childTwo 、childThird）并且一层层不断内嵌其中， 而在最深层的 childThird 组件中我们可以通过 inject 获取 for 这个变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123;demo&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    inject: [&apos;for&apos;],</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        demo: this.for</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h5 id="3-自定义指令如何定义，它的生命周期是什么？"><a href="#3-自定义指令如何定义，它的生命周期是什么？" class="headerlink" title="3.自定义指令如何定义，它的生命周期是什么？"></a>3.自定义指令如何定义，它的生命周期是什么？</h5><p>通过 Vue.directive() 来定义全局指令</p><p>有几个可用的钩子（生命周期）, 每个钩子可以选择一些参数. 钩子如下:</p><ul><li>bind: 一旦指令附加到元素时触发</li><li>inserted: 一旦元素被添加到父元素时触发</li><li>update: 每当元素本身更新(但是子元素还未更新)时触发</li><li>componentUpdate: 每当组件和子组件被更新时触发</li><li>unbind: 一旦指令被移除时触发。</li></ul><p>bind 和 update 也许是这五个里面最有用的两个钩子了</p><p>每个钩子都有 el, binding, 和 vnode 参数可用.</p><p>update 和 componentUpdated 钩子还暴露了 oldVnode, 以区分传递的旧值和较新的值.</p><p>el 就是所绑定的元素.</p><p>binding 是一个保护传入钩子的参数的对象. 有很多可用的参数, 包括 name, value, oldValue, expression, arguments, arg 及修饰语.</p><p>vnode 有一个更不寻常的用例, 它可用于你需要直接引用到虚拟 DOM 中的节点.</p><p>binding 和 vnode 都应该被视为只读.</p><p>现在，自定义一个指令，添加一些样式，表示定位的距离<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;tack&apos;,&#123;</span><br><span class="line"> bind(el,binding)&#123;</span><br><span class="line">  el.style.position=&apos;fixed&apos;;</span><br><span class="line">  el.style.top=binding.value + &apos;px&apos;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;div class=&quot;header&quot; v-tack=&quot;10&quot; &gt;我是header&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>假设我们想要区分从顶部或者左侧偏移 70px, 我们可以通过传递一个参数来做到这一点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;tack&apos;, &#123;</span><br><span class="line"> bind(el, binding, vnode) &#123;</span><br><span class="line">  el.style.position = &apos;fixed&apos;;</span><br><span class="line">  const s = (binding.arg === &apos;left&apos; ? &apos;left&apos; : &apos;top&apos;);</span><br><span class="line">  el.style[s] = binding.value + &apos;px&apos;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>也可以同时传入不止一个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;tack&apos;, &#123;</span><br><span class="line"> bind(el, binding, vnode) &#123;</span><br><span class="line"> el.style.position = &apos;fixed&apos;;</span><br><span class="line"> el.style.top = binding.value.top + &apos;px&apos;;</span><br><span class="line"> el.style.left = binding.value.left + &apos;px&apos;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;div class=&quot;header&quot; v-tack=&quot;&#123;left:’20’,top:’20’&#125;&quot; &gt;我是header&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h5 id="4、vue-生命周期，各个阶段简单讲一下？"><a href="#4、vue-生命周期，各个阶段简单讲一下？" class="headerlink" title="4、vue 生命周期，各个阶段简单讲一下？"></a>4、vue 生命周期，各个阶段简单讲一下？</h5><ul><li>breforeCreate（）：实例创建前，这个阶段实例的 data 和 methods 是读不到的。</li><li>created（）：实例创建后，这个阶段已经完成数据观测，属性和方法的运算，watch/event 事件回调，mount 挂载阶段还没有开始。$el 属性目前不可见，数据并没有在 DOM 元素上进行渲染。<br>created 完成之后，进行 template 编译等操作，将 template 编译为 render 函数，有了 render 函数后才会执行 beforeMount（）</li><li>beforeMount（）：在挂载开始之前被调用：相关的 render 函数首次被调用</li><li>mounted（）：挂载之后调用，el 选项的 DOM 节点被新创建的 vm.$el 替换，并挂载到实例上去之后调用此生命周期函数，此时实例的数据在 DOM 节点上进行渲染</li></ul><p>后续的钩子函数执行的过程都是需要外部的触发才会执行</p><p>有数据的变化，会调用 beforeUpdate，然后经过 Virtual Dom，最后 updated 更新完毕，当组件被销毁的时候，会调用 beforeDestory，以及 destoryed。</p><h5 id="5、watch-和-computed-的区别？"><a href="#5、watch-和-computed-的区别？" class="headerlink" title="5、watch 和 computed 的区别？"></a>5、watch 和 computed 的区别？</h5><p><strong>computed</strong>：</p><p>① 有缓存机制；② 不能接受参数；③ 可以依赖其他 computed，甚至是其他组件的 data；④ 不能与 data 中的属性重复</p><p><strong>watch</strong>：</p><p>① 可接受两个参数；② 监听时可触发一个回调，并做一些事情；③ 监听的属性必须是存在的；④ 允许异步<br>watch 配置：handler、deep（是否深度）、immeditate （是否立即执行）</p><p>总结：</p><p>当有一些数据需要随着另外一些数据变化时，建议使用 computed</p><p>当有一个通用的响应数据变化的时候，要执行一些业务逻辑或异步操作的时候建议使用 watch</p><h5 id="6、请说一下-computed-中的-getter-和-setter"><a href="#6、请说一下-computed-中的-getter-和-setter" class="headerlink" title="6、请说一下 computed 中的 getter 和 setter"></a>6、请说一下 computed 中的 getter 和 setter</h5><p>① computed 中可以分成 getter（读取） 和 setter（设值）</p><p>② 一般情况下是没有 setter 的，computed 预设只有 getter ，也就是只能读取，不能改变设值。</p><p>一、默认只有 getter 的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//其实fullName的完整写法应该是如下：</span><br><span class="line">fullName: &#123;</span><br><span class="line"> get()&#123;</span><br><span class="line">   return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：不是说我们更改了 getter 里使用的变量，就会触发 computed 的更新，前提是 computed 里的值必须要在模板里使用才行。如果将去掉，get（）方法是不会触发的。</p><p>二、setter 的写法，可以设值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">       &lt;p&gt; &#123;&#123; fullName &#125;&#125; &lt;/p&gt;</span><br><span class="line">       &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt;</span><br><span class="line">       &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;</span><br><span class="line">       &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;zhang&apos;,</span><br><span class="line">    lastName: &apos;san&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: &#123;</span><br><span class="line">      //getter 方法</span><br><span class="line">     get()&#123;</span><br><span class="line">       console.log(&apos;computed getter...&apos;)</span><br><span class="line">        return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">       &#125;，</span><br><span class="line">   //setter 方法</span><br><span class="line">    set(newValue)&#123;</span><br><span class="line">      console.log(&apos;computed setter...&apos;)</span><br><span class="line">      var names = newValue.split(&apos; &apos;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在这里，我们修改 fullName 的值，就会触发 setter，同时也会触发 getter。</p><p>注意：并不是触发了 setter 也就会触发 getter，他们两个是相互独立的。我们这里修改了 fullName 会触发 getter 是因为 setter 函数里有改变 firstName 和 lastName 值的代码，这两个值改变了，fullName 依赖于这两个值，所以便会自动改变。</p><h5 id="7、导航钩子有哪几种，分别如何用，如何将数据传入下一个点击的路由页面？"><a href="#7、导航钩子有哪几种，分别如何用，如何将数据传入下一个点击的路由页面？" class="headerlink" title="7、导航钩子有哪几种，分别如何用，如何将数据传入下一个点击的路由页面？"></a>7、导航钩子有哪几种，分别如何用，如何将数据传入下一个点击的路由页面？</h5><p>① 全局导航守卫</p><p>前置守卫<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // do someting</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>后置钩子（没有 next 参数）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // do someting</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>② 路由独享守卫<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cont router = new  VueRouter(&#123;</span><br><span class="line"> routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/file&apos;,</span><br><span class="line">    component: File,</span><br><span class="line">    beforeEnter: (to, from ,next) =&gt; &#123;</span><br><span class="line">       // do someting</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>顺便看一下路由里面的参数配置：<br><img src="img/aiqianduan/WX20200318-180317@2x.png" alt="1584102761161.jpg"><br>③ 组件内的导航钩子</p><p>组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。他们是直接在路由组件内部直接进行定义的</p><p><strong>beforeRouteEnter</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line"> return&#123;</span><br><span class="line">   pro:&apos;产品&apos;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteEnter:(to,from,next)=&gt;&#123;</span><br><span class="line">  console.log(to)</span><br><span class="line">  next(vm =&gt; &#123;</span><br><span class="line">   console.log(vm.pro)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注：beforeRouteEnter 不能获取组件实例 this，因为当守卫执行前，组件实例被没有被创建出来，我们可以通过给 next 传入一个回调来访问组件实例。在导航被确认时，会执行这个回调，这时就可以访问组件实例了</p><p>仅仅是 beforRouteEnter 支持给 next 传递回调，其他两个并不支持，因为剩下两个钩子可以正常获取组件实例 this</p><p>如何通过路由将数据传入下一个跳转的页面呢？</p><p>答：params 和 query</p><p><strong>params</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 传参</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line"> name:&quot;detail&quot;,</span><br><span class="line"> params:&#123;</span><br><span class="line">   name:&apos;xiaoming&apos;,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 接受</span><br><span class="line">this.$route.params.name</span><br></pre></td></tr></table></figure></p><p><strong>query</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 传参</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">  path:&apos;/detail&apos;,</span><br><span class="line">  query:&#123;</span><br><span class="line">    name:&quot;xiaoming&quot;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">// 接受 </span><br><span class="line">// 接收参数是this.$route</span><br><span class="line">this.$route.query.id</span><br></pre></td></tr></table></figure></p><p>那 query 和 params 什么区别呢？</p><p>① params 只能用 name 来引入路由，query 既可以用 name 又可以用 path（通常用 path）</p><p>② params 类似于 post 方法，参数不会再地址栏中显示<br><img src="img/aiqianduan/WX20200318-180355@2x.png" alt="1584103255885.jpg"><br>query 类似于 get 请求，页面跳转的时候，可以在地址栏看到请求参数<br><img src="img/aiqianduan/WX20200318-180412@2x.png" alt="1584103320555.jpg"><br>那刚才提到的 this.router和this.route有何区别？</p><p>先打印出来看一下<br><img src="img/aiqianduan/WX20200318-180430@2x.png" alt="1584103429182.jpg"><br>router.push 方法</p><p>$route 为当前 router 跳转对象，里面可以获取 name、path、query、params 等</p><h5 id="8、es6-的特有的类型，-常用的操作数组的方法都有哪些？"><a href="#8、es6-的特有的类型，-常用的操作数组的方法都有哪些？" class="headerlink" title="8、es6 的特有的类型， 常用的操作数组的方法都有哪些？"></a>8、es6 的特有的类型， 常用的操作数组的方法都有哪些？</h5><p>es6 新增的主要的特性：</p><p>① let const 两者都有块级作用域</p><p>② 箭头函数</p><p>③ 模板字符串</p><p>④ 解构赋值</p><p>⑤ for of 循环</p><p>⑥ import 、export 导入导出</p><p>⑦ set 数据结构</p><p>⑧ …展开运算符</p><p>⑨ 修饰器 @</p><p>⑩ class 类继承</p><p>⑪ async、await</p><p>⑫ promise</p><p>⑬ Symbol</p><p>⑭ Proxy 代理</p><p>操作数组常用的方法：</p><p><strong>es5</strong>：concat 、join 、push、pop、shift、unshift、slice、splice、substring 和 substr 、sort、 reverse、indexOf 和 lastIndexOf 、every、some、filter、map、forEach、reduce</p><p><strong>es6</strong>：find、findIndex、fill、copyWithin、Array.from、Array.of、entries、values、key、includes</p><h5 id="9、vue-双向绑定原理？"><a href="#9、vue-双向绑定原理？" class="headerlink" title="9、vue 双向绑定原理？"></a>9、vue 双向绑定原理？</h5><p>通过 Object.defineProperty()来劫持各个属性的 setter,getter，在数据变动时发布消息给订阅者，触发相应的监听回调</p><h5 id="10、vue-router-的实现原理，history-和-hash-模式有什么区别？"><a href="#10、vue-router-的实现原理，history-和-hash-模式有什么区别？" class="headerlink" title="10、vue-router 的实现原理，history 和 hash 模式有什么区别？"></a>10、vue-router 的实现原理，history 和 hash 模式有什么区别？</h5><p>vue-router 有两种模式，hash 模式和 history 模式</p><p><strong>hash 模式</strong></p><p>url 中带有#的便是 hash 模式，#后面是 hash 值，它的变化会触发 hashchange 这个事件。</p><p>通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听 hashchange 来实现更新页面部分内容的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = function(event)&#123;</span><br><span class="line">  console.log(event.oldURL, event.newURL);</span><br><span class="line">  let hash = location.hash.slice(1);</span><br><span class="line">  document.body.style.color = hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外，hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。</p><p><strong>history 模式</strong></p><p>history api 可以分为两大部分，切换和修改</p><p>① 切换历史状态</p><p>包括 back,forward,go 三个方法，对应浏览器的前进，后退，跳转操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.go(-2);//后退两次</span><br><span class="line">history.go(2);//前进两次</span><br><span class="line">history.back(); //后退</span><br><span class="line">hsitory.forward(); //前进</span><br></pre></td></tr></table></figure></p><p>② 修改历史状态</p><p>包括了 pushState,replaceState 两个方法,这两个方法接收三个参数:stateObj,title,url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;color:&apos;red&apos;&#125;, &apos;red&apos;, &apos;red&apos;&#125;)</span><br><span class="line">window.onpopstate = function(event)&#123;</span><br><span class="line">  console.log(event.state)</span><br><span class="line">  if(event.state &amp;&amp; event.state.color === &apos;red&apos;)&#123;</span><br><span class="line">    document.body.style.color = &apos;red&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">history.back();</span><br><span class="line">history.forward();</span><br></pre></td></tr></table></figure></p><p>通过 pushstate 把页面的状态保存在 state 对象中，当页面的 url 再变回这个 url 时，可以通过 event.state 取到这个 state 对象，从而可以对页面状态进行还原，这里的页面状态就是页面字体颜色，其实滚动条的位置，阅读进度，组件的开关的这些页面状态都可以存储到 state 的里面。</p><p>history 缺点：</p><p>1：hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如<a href="http://www.a12c.com,因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回" target="_blank" rel="noopener">http://www.a12c.com,因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回</a> 404 错误。</p><p>2：history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致。如<a href="http://www.a12c.com/book/a。如果后端缺少对/book/a" target="_blank" rel="noopener">http://www.a12c.com/book/a。如果后端缺少对/book/a</a> 的路由处理，将返回 404 错误</p><h5 id="11、怎么在vue中点击别的区域输入框不会失去焦点？"><a href="#11、怎么在vue中点击别的区域输入框不会失去焦点？" class="headerlink" title="11、怎么在vue中点击别的区域输入框不会失去焦点？"></a>11、怎么在vue中点击别的区域输入框不会失去焦点？</h5><p>答：阻止事件的默认行为</p><p>具体操作：监听你想点击后不会丢失 input 焦点的那个元素的 mousedown 事件，回调里面调用 event.preventDefault()，会阻止使当前焦点丢失这一默认行为。</p><h5 id="12、vue中data的属性可以和methods中的方法同名吗？为什么？"><a href="#12、vue中data的属性可以和methods中的方法同名吗？为什么？" class="headerlink" title="12、vue中data的属性可以和methods中的方法同名吗？为什么？"></a>12、vue中data的属性可以和methods中的方法同名吗？为什么？</h5><p>答：不可以</p><p>因为，Vue会把methods和data的东西，全部代理到Vue生成的对象中，会产生覆盖所以最好不要同名</p><h5 id="13、怎么给vue定义全局的方法？"><a href="#13、怎么给vue定义全局的方法？" class="headerlink" title="13、怎么给vue定义全局的方法？"></a>13、怎么给vue定义全局的方法？</h5><p>Vue.prototype.方法名称</p><h5 id="14、Vue-2-0-不再支持在-v-html-中使用过滤器怎么办？"><a href="#14、Vue-2-0-不再支持在-v-html-中使用过滤器怎么办？" class="headerlink" title="14、Vue 2.0 不再支持在 v-html 中使用过滤器怎么办？"></a>14、Vue 2.0 不再支持在 v-html 中使用过滤器怎么办？</h5><p>解决方法：</p><p>①全局方法（推荐）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.msg = function（msg）&#123;</span><br><span class="line">  return msg.replace（&quot;\n&quot;，&quot;&lt;br&gt;&quot;）</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;div v-html=&quot;msg(content)&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>②computed方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed：&#123;</span><br><span class="line"> content：function(msg)&#123;</span><br><span class="line">  return msg.replace(&quot;\n&quot;，&quot;&lt;br&gt;&quot;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>③$options.filters(推荐)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filters：&#123;</span><br><span class="line"> msg：function(msg)&#123;</span><br><span class="line">  return msg.replace(/\n/g，&quot;&lt;br&gt;&quot;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;，  　　</span><br><span class="line">data：&#123;</span><br><span class="line"> content：&quot;XXXX&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div v-html=&quot;$options.filters.msg(content)&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h5 id="14、怎么解决vue打包后静态资源图片失效的问题？"><a href="#14、怎么解决vue打包后静态资源图片失效的问题？" class="headerlink" title="14、怎么解决vue打包后静态资源图片失效的问题？"></a>14、怎么解决vue打包后静态资源图片失效的问题？</h5><p>答：将静态资源的存放位置放在src目录下</p><h5 id="16、怎么解决vue动态设置img的src不生效的问题？"><a href="#16、怎么解决vue动态设置img的src不生效的问题？" class="headerlink" title="16、怎么解决vue动态设置img的src不生效的问题？"></a>16、怎么解决vue动态设置img的src不生效的问题？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;img class=&quot;logo&quot; :src=&quot;logo&quot; alt=&quot;公司logo&quot;&gt;</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    logo:require(&quot;./../assets/images/logo.png&quot;),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为动态添加src被当做静态资源处理了，没有进行编译，所以要加上require</p><h5 id="17、跟keep-alive有关的生命周期是哪些？描述下这些生命周期"><a href="#17、跟keep-alive有关的生命周期是哪些？描述下这些生命周期" class="headerlink" title="17、跟keep-alive有关的生命周期是哪些？描述下这些生命周期"></a>17、跟keep-alive有关的生命周期是哪些？描述下这些生命周期</h5><p>activated和deactivated两个生命周期函数</p><p>1.<strong>activated</strong>：当组件激活时，钩子触发的顺序是created-&gt;mounted-&gt;activated</p><p>2.<strong>deactivated</strong>: 组件停用时会触发deactivated，当再次前进或者后退的时候只触发activated</p><h5 id="18、你知道vue中key的原理吗？说说你对它的理解"><a href="#18、你知道vue中key的原理吗？说说你对它的理解" class="headerlink" title="18、你知道vue中key的原理吗？说说你对它的理解"></a>18、你知道vue中key的原理吗？说说你对它的理解</h5><p>暂时没弄明白，等会儿写</p><h5 id="19、vue中怎么重置data？"><a href="#19、vue中怎么重置data？" class="headerlink" title="19、vue中怎么重置data？"></a>19、vue中怎么重置data？</h5><p>答：Object.assign()</p><p>Object.assign（）方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123; a: 1 &#125;;</span><br><span class="line">var o2 = &#123; b: 2 &#125;;</span><br><span class="line">var o3 = &#123; c: 3 &#125;;</span><br><span class="line">var obj = Object.assign(o1, o2, o3);</span><br><span class="line">console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;,注意目标对象自身也会改变。</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>，具有相同属性的对象，同名属性，后边的会覆盖前边的。</p><p>由于Object.assign()有上述特性，所以我们在Vue中可以这样使用：</p><p>Vue组件可能会有这样的需求：在某种情况下，需要重置Vue组件的data数据。此时，我们可以通过this.$data获取当前状态下的data，通过this.$options.data()获取该组件初始状态下的data。</p><p>然后只要使用<strong>Object.assign(this.options.data())</strong>就可以将当前状态的data重置为初始状态。</p><h5 id="20、vue怎么实现强制刷新组件？"><a href="#20、vue怎么实现强制刷新组件？" class="headerlink" title="20、vue怎么实现强制刷新组件？"></a>20、vue怎么实现强制刷新组件？</h5><p>答：① v-if ② this.$forceUpdate</p><p>v-if<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//当v-if的值发生变化时，组件都会被重新渲染一遍。因此，利用v-if指令的特性，可以达到强制</span><br><span class="line">&lt;comp v-if=&quot;update&quot;&gt;&lt;/comp&gt;</span><br><span class="line">&lt;button @click=&quot;reload()&quot;&gt;刷新comp组件&lt;/button&gt;</span><br><span class="line">data() &#123;</span><br><span class="line"> return &#123;</span><br><span class="line">   update: true</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods: &#123;</span><br><span class="line">  reload() &#123;</span><br><span class="line">     // 移除组件</span><br><span class="line">    this.update = false</span><br><span class="line">      // 在组件移除后，重新渲染组件</span><br><span class="line">      // this.$nextTick可实现在DOM 状态更新后，执行传入的方法。</span><br><span class="line">    this.$nextTick(() =&gt; &#123;</span><br><span class="line">      this.update = true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>this.$forceUpdate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;reload()&quot;&gt;刷新当前组件&lt;/button&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  reload() &#123;</span><br><span class="line">    this.$forceUpdate()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="21、vue如何优化首页的加载速度？"><a href="#21、vue如何优化首页的加载速度？" class="headerlink" title="21、vue如何优化首页的加载速度？"></a>21、vue如何优化首页的加载速度？</h5><p>① 第三方js库按CDN引入（一、cdn引入 二、去掉第三方库引入的import 三、把第三方库的js文件从打包文件里去掉）</p><p>② vue-router路由懒加载</p><p>③ 压缩图片资源</p><p>④ 静态文件本地缓存</p><p>http缓存：推荐网站：<a href="https://www.cnblogs.com/chinajava/p/5705169.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinajava/p/5705169.html</a><br>service worker离线缓存:，缺点：需要在HTTPS站点下，推荐：<a href="http://lzw.me/a/pwa-service-worker.html" target="_blank" rel="noopener">http://lzw.me/a/pwa-service-worker.html</a></p><p>⑤ 服务器端SSR渲染<br>除了上面的方案以外，另一种方案也不容小视<br>我们先说说通常项目中是如何加载页面数据：Vue组件生命周期中请求异步接口，在mounted之前应该都可以，据我了解绝大部分同学是在mounted的时候执行异步请求。但是我们可以把页面需要的请求放到Vue-Router的守卫中执行，意思是在路由beforeEnter之前就可以请求待加载页面中所有组件需要的数据，此时待加载页面的Vue组件还没开始渲染，而Vue组件开始渲染的时候我们就可以用Vuex里面的数据了。<br>以上方法的实现思路：<br><img src="img/aiqianduan/WX20200318-180459@2x.png" alt="1584104477342.jpg"><br>图意：每个页面（Page）中都会有很多个Vue组件，可以在Vue组件中添加自定义属性fetchData，fetchData里面可以执行异步请求（图中执行Vuex的Action），但是我们怎么获取到所有组件的fetchData方法并执行呢？如图所示，在router.beforeResolve守卫中，我们看看router.beforeResolve的定义，所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用，意思是即使页面中有异步组件，它会等待异步组件解析之后执行，并且解析守卫在beforeEnter之前执行。那我们怎么在解析守卫中获取到待加载页面的所有组件呢？通过router.getMatchedComponents方法。<br><img src="img/aiqianduan/WX20200318-180522@2x.png" alt="1584104536697.jpg"><br><img src="img/aiqianduan/WX20200318-180538@2x.png" alt="1584104524469.jpg"><br>这样我们就可以在解析守卫中获取到所有待加载组件的fetchData方法并执行，这样无疑会在组件开始渲染之后获取到所有数据，提高页面加载速度。以上方法的实现思路：</p><p>很多人可能有个疑问，如果异步请求放在beforeCreate和created不是一样吗？答案是否定的，因为这种方式可以将异步请求放到beforeCreate之前！</p><h5 id="22、你了解vue的diff算法吗？"><a href="#22、你了解vue的diff算法吗？" class="headerlink" title="22、你了解vue的diff算法吗？"></a>22、你了解vue的diff算法吗？</h5><p>推荐网站：<a href="https://www.cnblogs.com/wind-lanyan/p/9061684.html" target="_blank" rel="noopener">https://www.cnblogs.com/wind-lanyan/p/9061684.html</a></p><h5 id="23、vue能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？"><a href="#23、vue能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？" class="headerlink" title="23、vue能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？"></a>23、vue能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？</h5><p>Vue.js观察数组变化主要通过以下7个方法（push、pop、shift、unshift、splice、sort、reverse）</p><p>大家知道，通过Object.defineProperty()劫持数组为其设置getter和setter后，调用的数组的push、splice、pop等方法改变数组元素时并不会触发数组的setter，继而数组的数据变化并不是响应式的，但是vue实际开发中却是实时响应的，是因为vue重写了数组的push、splice、pop等方法</p><p>从源码中可以看出，ob.dep.notify()将当前数组的变更通知给其订阅者，这样当使用重写后方法改变数组后，数组订阅者会将这边变化更新到页面中</p><h5 id="24、说说你对proxy的理解？"><a href="#24、说说你对proxy的理解？" class="headerlink" title="24、说说你对proxy的理解？"></a>24、说说你对proxy的理解？</h5><p>Proxy用于修改某些操作的默认行为，也可以理解为在目标对象之前架设一层拦截，外部所有的访问都必须先通过这层拦截，因此提供了一种机制，可以对外部的访问进行过滤和修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123;</span><br><span class="line">   name: &apos;zhangsan&apos;,</span><br><span class="line">   age:20,</span><br><span class="line">   sex:&apos;男&apos;</span><br><span class="line"> &#125;</span><br><span class="line">var logHandler = &#123;</span><br><span class="line">  get(target, key) &#123;</span><br><span class="line">    console.log(`$&#123;key&#125;被读取`)</span><br><span class="line">    return target[key]</span><br><span class="line">   &#125;,</span><br><span class="line">  set(target, key, value) &#123;</span><br><span class="line">    console.log(`$&#123;key&#125;被设置为$&#123;value&#125;`)</span><br><span class="line">    target[key] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var demo = new Proxy(target, logHandler)</span><br><span class="line">demo.name  //name被读取</span><br></pre></td></tr></table></figure></p><p>var proxy = new Proxy(target, handler);</p><p>Proxy对象的所有用法，都是上面的这种形式。不同的只是handle参数的写法。其中new Proxy用来生成Proxy实例，target是表示所要拦截的对象，handle是用来定制拦截行为的对象。</p><p>我们可以将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123; proxy: new Proxy(target, handler) &#125;;</span><br></pre></td></tr></table></figure></p><p>Proxy对象也可以作为其它对象的原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">let obj = Object.create(proxy);</span><br><span class="line">obj.time // 35</span><br></pre></td></tr></table></figure></p><p>上面代码中，proxy对象是obj的原型对象，obj本身并没有time属性，所以根据原型链，会在proxy对象上读取属性，从而被拦截。</p><p>同一个拦截函数，可以设置多个操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  get: function (target, name) &#123;</span><br><span class="line">    if (name === &apos;prototype&apos;) &#123;</span><br><span class="line">       return Object.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    return &apos;Hello, &apos; + name;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  apply: function (target, thisBinding, args) &#123;</span><br><span class="line">    return args[0];</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  construct: function (target, args) &#123;</span><br><span class="line">    return &#123; value: args[1] &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">var fproxy = new Proxy(function (x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"> </span><br><span class="line">fproxy(1, 2) // 1</span><br><span class="line">new fproxy(1, 2) // &#123;value: 2&#125;</span><br><span class="line">fproxy.prototype === Object.prototype // true</span><br><span class="line">fproxy.foo === &quot;Hello, foo&quot; // true</span><br></pre></td></tr></table></figure></p><h5 id="25、怎么缓存当前的组件？缓存后怎么更新？"><a href="#25、怎么缓存当前的组件？缓存后怎么更新？" class="headerlink" title="25、怎么缓存当前的组件？缓存后怎么更新？"></a>25、怎么缓存当前的组件？缓存后怎么更新？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;!-- 这里是需要keepalive的 --&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;!-- 这里不会被keepalive --&gt;</span><br><span class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&#123;</span><br><span class="line">  path: &apos;&apos;,</span><br><span class="line">  name: &apos;&apos;,</span><br><span class="line">  component: ,</span><br><span class="line">  meta: &#123;keepAlive: true&#125; // 这个是需要keepalive的</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: &apos;&apos;,</span><br><span class="line">  name: &apos;&apos;,</span><br><span class="line">  component: ,</span><br><span class="line">  meta: &#123;keepAlive: false&#125; // 这是不会被keepalive的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果缓存的组件想要清空数据或者执行初始化方法，在加载组件的时候调用activated钩子函数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">activated: function () &#123;</span><br><span class="line">    this.data = &apos;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="26、axios怎么解决跨域的问题？"><a href="#26、axios怎么解决跨域的问题？" class="headerlink" title="26、axios怎么解决跨域的问题？"></a>26、axios怎么解决跨域的问题？</h5><p>使用axios直接进行跨域访问不可行，我们需要配置代理</p><p>代理可以解决的原因：</p><p>因为客户端请求服务端的数据是存在跨域问题的，而==服务器和服务器之间可以相互请求数据，是没有跨域的概念==（如果服务器没有设置禁止跨域的权限问题），也就是说，我们可以配置一个代理的服务器可以请求另一个服务器中的数据，然后把请求出来的数据返回到我们的代理服务器中，代理服务器再返回数据给我们的客户端，这样我们就可以实现跨域访问数据</p><p>1.配置BaseUrl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">Vue.prototype.$axios = axios</span><br><span class="line">axios.defaults.baseURL = &apos;/api&apos;  //关键代码</span><br></pre></td></tr></table></figure></p><p>2.配置代理</p><p>在config文件夹下的index.js文件中的proxyTable字段中，作如下处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line"> &apos;/api&apos;: &#123;</span><br><span class="line">   target:&apos;http://api.douban.com/v2&apos;, // 你请求的第三方接口</span><br><span class="line">   changeOrigin:true,</span><br><span class="line">// 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，</span><br><span class="line">//这样服务端和服务端进行数据的交互就不会有跨域问题</span><br><span class="line">   pathRewrite:&#123;  // 路径重写，</span><br><span class="line">    &apos;^/api&apos;: &apos;&apos;</span><br><span class="line">// 替换target中的请求地址，也就是说以后你在请求http://api.douban.com/v2/XXXXX</span><br><span class="line">//这个地址的时候直接写成/api即可。</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>在具体使用axios的地方，修改url如下即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&quot;/movie/top250&quot;).then((res) =&gt; &#123;</span><br><span class="line">  res = res.data</span><br><span class="line">  if (res.errno === ERR_OK) &#123;</span><br><span class="line">    this.themeList=res.data;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;).catch((error) =&gt; &#123;</span><br><span class="line">  console.warn(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>原理：</p><p>因为我们给url加上了前缀/api，我们访问/movie/top250就当于访问了：localhost:8080/api/movie/top250（其中localhost:8080是默认的IP和端口）。</p><p>在index.js中的proxyTable中拦截了/api,<strong>并把/api及其前面的所有</strong>替换成了target中的内容，因此实际访问Url是<a href="http://api.douban.com/v2/movie/top250。" target="_blank" rel="noopener">http://api.douban.com/v2/movie/top250。</a></p><p>至此，纯前端配置代理解决axios跨域得到解决</p><h5 id="27、怎么实现路由懒加载呢？"><a href="#27、怎么实现路由懒加载呢？" class="headerlink" title="27、怎么实现路由懒加载呢？"></a>27、怎么实现路由懒加载呢？</h5><p>第一种（最常用）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; import(&apos;./Foo.vue&apos;)</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/foo&apos;, component: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>第二种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const router = new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">   &#123;</span><br><span class="line">     path: &apos;/index&apos;,</span><br><span class="line">     component: (resolve) =&gt; &#123;</span><br><span class="line">        require([&apos;../components/index&apos;], resolve) // 这里是你的模块 不用import去引入了</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>第三种（官方推荐）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// r就是resolve</span><br><span class="line">const list = r =&gt; require.ensure([], () =&gt; r(require(&apos;../components/list/list&apos;)), &apos;list&apos;);</span><br><span class="line">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载</span><br><span class="line">const router = new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/list/blog&apos;,</span><br><span class="line">    component: list,</span><br><span class="line">    name: &apos;blog&apos;</span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="28、怎样动态加载路由？"><a href="#28、怎样动态加载路由？" class="headerlink" title="28、怎样动态加载路由？"></a>28、怎样动态加载路由？</h5><p>一、思路</p><p>① 在vue-router对象中首先<strong>初始化公共路由</strong>，比如（首页，404，login）等</p><p>② 用户登陆成功后，根据用户的角色信息，<strong>获取对应权限菜单信息menuList</strong>，并将后台返回的menuList转换成我们需要的router数据结构</p><p>③ 通过<strong>router.addRouter(routes)</strong>方法，同时我们可以将转后的路由信息保存于vuex，这样我们可以在我们的SideBar组件中获取我们的全部路由信息，并且渲染我们的左侧菜单栏，让动态路由实现。</p><p>二、实现</p><p>① 初始化公共路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//只显示主要代码</span><br><span class="line">export const routes= [</span><br><span class="line"> &#123; path: &apos;/login&apos;, component: () =&gt; import(&apos;@/views/login/index&apos;), hidden: true &#125;,</span><br><span class="line"> &#123; path: &apos;/404&apos;, component: () =&gt; import(&apos;@/views/404&apos;), hidden: true &#125;</span><br><span class="line">]</span><br><span class="line">export default new Router(&#123;</span><br><span class="line"> scrollBehavior: () =&gt; (&#123; y: 0 &#125;),</span><br><span class="line"> routes: routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>② 登陆成功后，获取菜单信息menuList，并转换成router数组的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line"> NProgress.start()//进度条包 npm安装</span><br><span class="line"> if (getToken()) &#123;</span><br><span class="line">  /*有 token，已经登录成功*/</span><br><span class="line">  if (to.path === &apos;/login&apos;) &#123;</span><br><span class="line">   next(&#123; path: &apos;/&apos; &#125;)</span><br><span class="line">   NProgress.done()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">   if (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完user_info信息</span><br><span class="line">    store.dispatch(&apos;GetInfo&apos;).then(res =&gt; &#123; // 拉取user_info</span><br><span class="line">     const roles = res.roles</span><br><span class="line">     store.dispatch(&quot;GetMenu&quot;).then(data =&gt; &#123;</span><br><span class="line">      initMenu(router, data);</span><br><span class="line">     &#125;);</span><br><span class="line">     next()</span><br><span class="line">    &#125;).catch((err) =&gt; &#123;</span><br><span class="line">     store.dispatch(&apos;FedLogOut&apos;).then(() =&gt; &#123;</span><br><span class="line">      Message.error(err || &apos;Verification failed, please login again&apos;)</span><br><span class="line">      next(&#123; path: &apos;/&apos; &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">    next()</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  /* 无 token*/</span><br><span class="line">  if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入</span><br><span class="line">   next()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">   next(&apos;/login&apos;) // 否则全部重定向到登录页</span><br><span class="line">   NProgress.done()</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line">router.afterEach(() =&gt; &#123;</span><br><span class="line"> NProgress.done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>③ 动态加载路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import store from &apos;../store&apos;</span><br><span class="line">export const initMenu = (router, menu) =&gt; &#123;</span><br><span class="line"> if (menu.length === 0) &#123;</span><br><span class="line">  return</span><br><span class="line"> &#125;</span><br><span class="line"> let menus = formatRoutes(menu);</span><br><span class="line"> </span><br><span class="line"> let unfound = &#123; path: &apos;*&apos;, redirect: &apos;/404&apos;, hidden: true &#125;</span><br><span class="line"> menus.push(unfound) //404组件最后添加</span><br><span class="line"> router.addRoutes(menus)</span><br><span class="line"> store.commit(&apos;ADD_ROUTERS&apos;,menus)</span><br><span class="line">&#125;</span><br><span class="line">export const formatRoutes = (aMenu) =&gt; &#123;</span><br><span class="line"> const aRouter = []</span><br><span class="line"> aMenu.forEach(oMenu =&gt; &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">   path,</span><br><span class="line">   component,</span><br><span class="line">   name,</span><br><span class="line">   icon,</span><br><span class="line">   childrens</span><br><span class="line">  &#125; = oMenu</span><br><span class="line">  if (!validatenull(component)) &#123;</span><br><span class="line">   let filePath;</span><br><span class="line">   const oRouter = &#123;</span><br><span class="line">    path: path,</span><br><span class="line">    component(resolve) &#123;</span><br><span class="line">     let componentPath = &apos;&apos;</span><br><span class="line">     if (component === &apos;Layout&apos;) &#123;</span><br><span class="line">      require([&apos;../views/layout/Layout&apos;], resolve)</span><br><span class="line">      return</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">      componentPath = component</span><br><span class="line">     &#125;</span><br><span class="line">     require([`../$&#123;componentPath&#125;.vue`], resolve)</span><br><span class="line">    &#125;,</span><br><span class="line">    name: name,</span><br><span class="line">    icon: icon,</span><br><span class="line">    children: validatenull(childrens) ? [] : formatRoutes(childrens)</span><br><span class="line">   &#125;</span><br><span class="line">   aRouter.push(oRouter)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> return aRouter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>④ 渲染菜单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;el-scrollbar wrapClass=&quot;scrollbar-wrapper&quot;&gt;</span><br><span class="line">  &lt;el-menu</span><br><span class="line">   mode=&quot;vertical&quot;</span><br><span class="line">   :show-timeout=&quot;200&quot;</span><br><span class="line">   :default-active=&quot;$route.path&quot;</span><br><span class="line">   :collapse=&quot;isCollapse&quot;</span><br><span class="line">   background-color=&quot;#304156&quot;</span><br><span class="line">   text-color=&quot;#bfcbd9&quot;</span><br><span class="line">   active-text-color=&quot;#409EFF&quot;</span><br><span class="line">  &gt;</span><br><span class="line">   &lt;sidebar-item v-for=&quot;route in permission_routers&quot; :key=&quot;route.name&quot; :item=&quot;route&quot; :base-path=&quot;route.path&quot;&gt;&lt;/sidebar-item&gt;</span><br><span class="line">  &lt;/el-menu&gt;</span><br><span class="line"> &lt;/el-scrollbar&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class="line">import SidebarItem from &apos;./SidebarItem&apos;</span><br><span class="line">import &#123; validatenull &#125; from &quot;@/utils/validate&quot;;</span><br><span class="line">import &#123; initMenu &#125; from &quot;@/utils/util&quot;;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line"> components: &#123; SidebarItem &#125;,</span><br><span class="line"> created() &#123;</span><br><span class="line"> &#125;,</span><br><span class="line"> computed: &#123;</span><br><span class="line">  ...mapGetters([</span><br><span class="line">   &apos;permission_routers&apos;,</span><br><span class="line">   &apos;sidebar&apos;,</span><br><span class="line">   &apos;addRouters&apos;</span><br><span class="line">  ]),</span><br><span class="line">  isCollapse() &#123;</span><br><span class="line">   return !this.sidebar.opened</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>就这样我们动态加载路由就是实现了，关键点就是router.addRoute方法</p><p>⑤ 防坑</p><p>点击刷新的时候页面空白 控制台也不报错？</p><p>点击刷新，vue-router会重新初始化，那么我们之前的动态addRoute就不存在了，此时访问一个不存在的页面，所以我们的sidebar组件也就不会被访问，那么也无法获取菜单信息，就导致页面空白。所以我们需要把加载菜单信息这一步放在router的全局守卫beforeEach中就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export const initMenu = (router, menu) =&gt; &#123;</span><br><span class="line"> if (menu.length === 0) &#123;</span><br><span class="line">  return</span><br><span class="line"> &#125;</span><br><span class="line"> let menus = formatRoutes(menu);</span><br><span class="line"> // 最后添加</span><br><span class="line"> let unfound = &#123; path: &apos;*&apos;, redirect: &apos;/404&apos;, hidden: true &#125;</span><br><span class="line"> menus.push(unfound)</span><br><span class="line"> router.addRoutes(menus)</span><br><span class="line"> store.commit(&apos;ADD_ROUTERS&apos;,menus)</span><br><span class="line">&#125;</span><br><span class="line">//404组件一定要放在动态路由组件的最后，不然你刷新动态加载的页面，会跳转到404页面的</span><br></pre></td></tr></table></figure></p><h5 id="29、切换到新路由时，页面要滚动到顶部或保持原先的滚动位置怎么做呢？"><a href="#29、切换到新路由时，页面要滚动到顶部或保持原先的滚动位置怎么做呢？" class="headerlink" title="29、切换到新路由时，页面要滚动到顶部或保持原先的滚动位置怎么做呢？"></a>29、切换到新路由时，页面要滚动到顶部或保持原先的滚动位置怎么做呢？</h5><p>当创建一个 Router 实例，可以提供一个 scrollBehavior 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注意: 这个功能只在 HTML5 history 模式下可用。</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line"> routes: [...],</span><br><span class="line"> scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  // return 期望滚动到哪个的位置</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line"> return &#123; x: 0, y: 0 &#125;</span><br><span class="line">&#125; // 对于所有路由导航，简单地让页面滚动到顶部。</span><br></pre></td></tr></table></figure></p><p>返回 savedPosition，在按下 后退/前进 按钮时，在滚动条位置，就会像浏览器的原生表现那样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line"> if (savedPosition) &#123;</span><br><span class="line">  return savedPosition</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  return &#123; x: 0, y: 0 &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>模拟『滚动到锚点』的行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line"> if (to.hash) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">   selector: to.hash</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以利用路由元信息更细颗粒度地控制滚动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line"> &#123; path: &apos;/&apos;, component: Home, meta: &#123; scrollToTop: true &#125;&#125;,</span><br><span class="line"> &#123; path: &apos;/foo&apos;, component: Foo &#125;,</span><br><span class="line"> &#123; path: &apos;/bar&apos;, component: Bar, meta: &#123; scrollToTop: true &#125;&#125;</span><br><span class="line">]</span><br><span class="line">const scrollBehavior = (to, from, savedPosition) =&gt; &#123;</span><br><span class="line"> if (savedPosition) &#123;</span><br><span class="line">  return savedPosition</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  const position = &#123;&#125;</span><br><span class="line">  if (to.hash) &#123;</span><br><span class="line">   position.selector = to.hash</span><br><span class="line">  &#125;</span><br><span class="line">   if (to.matched.some(m =&gt; m.meta.scrollToTop)) &#123;</span><br><span class="line">   position.x = 0</span><br><span class="line">   position.y = 0</span><br><span class="line">  &#125;</span><br><span class="line">  return position</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以在main.js入口文件配合vue-router写这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to,from,next) =&gt; &#123;</span><br><span class="line">  window.scrollTo(0,0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="30、vue-router如何响应路由参数的变化？"><a href="#30、vue-router如何响应路由参数的变化？" class="headerlink" title="30、vue-router如何响应路由参数的变化？"></a>30、vue-router如何响应路由参数的变化？</h5><p>当使用路由参数时，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;path:’/list/:id’component:Foo&#125;</span><br></pre></td></tr></table></figure></p><p>从 /list/aside导航到 /list/foo，原来的组件实例会被复用。</p><p>因为两个路由都渲染同个组件Foo，比起销毁再创建，复用则更加高效。</p><p>不过，这也意味着组件的生命周期钩子不会再被调用。</p><p>如果跳转到相同的路由还会报以下错误<br><img src="img/aiqianduan/WX20200318-180600@2x.png" alt="1584105319470.jpg"><br>这个时候我们需要重写push方法，在src/router/index.js 里面import VueRouter from ‘vue-router’下面写入下面方法即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const routerPush = VueRouter.prototype.push</span><br><span class="line">VueRouter.prototype.push = function push(location) &#123;</span><br><span class="line">  return routerPush.call(this, location).catch(error=&gt; error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>如何响应不同的数据呢？</strong></p><p>① 复用组件时，想对路由参数的变化作出响应的话，你可以简单地 ==watch (监测变化) $route 对象==：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;...&apos;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &apos;$route&apos; (to, from) &#123;</span><br><span class="line">      // 对路由变化作出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>② 使用beforeRouteUpdate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;...&apos;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // react to route changes...</span><br><span class="line">    // don&apos;t forget to call next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：</p><p>（1）从同一个组件跳转到同一个组件。</p><p>（2）生命周期钩子created和mounted都不会调用。</p><h5 id="31、vue模板中为什么以-、-开始的变量无法渲染？"><a href="#31、vue模板中为什么以-、-开始的变量无法渲染？" class="headerlink" title="31、vue模板中为什么以_、$开始的变量无法渲染？"></a>31、vue模板中为什么以_、$开始的变量无法渲染？</h5><p>名字以_或$开始的属性不会被vue实例代理，因为它们可能与vue的内置属性与API方法冲突。用vm.data._property 访问它们。</p><h5 id="32、vue中，如何监听一个对象内部的变化？"><a href="#32、vue中，如何监听一个对象内部的变化？" class="headerlink" title="32、vue中，如何监听一个对象内部的变化？"></a>32、vue中，如何监听一个对象内部的变化？</h5><p>方法①：对整个obj深层监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line"> obj:&#123;</span><br><span class="line">  handler(newValue,oldValue)&#123;</span><br><span class="line">   console.log(&apos;obj changed&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  deep: true,//深度遍历</span><br><span class="line">  immediate: true</span><br><span class="line">//默认第一次绑定的时候不会触发watch监听，值为true时可以在最初绑定的时候执行</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法② ：指定key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    &quot;dataobj.name&quot;: &#123;</span><br><span class="line">      handler(newValue, oldValue) &#123;</span><br><span class="line">        console.log(&quot;obj changed&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>方法③：computed<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed()&#123;</span><br><span class="line"> ar()&#123;</span><br><span class="line">  return this.obj.name</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="33、v-for循环时为什么要加key？"><a href="#33、v-for循环时为什么要加key？" class="headerlink" title="33、v-for循环时为什么要加key？"></a>33、v-for循环时为什么要加key？</h5><p>key的作用主要是为了高效的更新虚拟DOM，是因为Virtual DOM 使用Diff算法实现的原因。</p><p>当某一层有很多相同的节点时，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上原则。</p><p>比如一下这个情况<br><img src="img/aiqianduan/WX20200318-180647@2x.png" alt="1584108439278.jpg"><br>我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的：<br><img src="img/aiqianduan/WX20200318-180708@2x.png" alt="1584108685723.jpg"><br>即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？</p><p>所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。<br><img src="img/aiqianduan/WX20200318-180720@2x.png" alt="1584108725115.jpg"></p><h5 id="34、-nextTick用过吗，有什么作用？"><a href="#34、-nextTick用过吗，有什么作用？" class="headerlink" title="34、$nextTick用过吗，有什么作用？"></a>34、$nextTick用过吗，有什么作用？</h5><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p><p>解决的问题：==有些时候在改变数据后立即要对dom进行操作==，此时获取到的dom仍是获取到的是数据刷新前的dom，无法满足需要，这个时候就用到了$nextTick。</p><h5 id="35、vue和react的区别是什么？"><a href="#35、vue和react的区别是什么？" class="headerlink" title="35、vue和react的区别是什么？"></a>35、vue和react的区别是什么？</h5><p>① React严格上只针对MVC的view层,Vue则是MVVM模式</p><p>② virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</p><p>③ 组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即’all in js’; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件;</p><p>④ 数据绑定: vue实现了数据的双向绑定,react数据流动是单向的</p><p>⑤ state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理</p>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
          <category> 笔记 </category>
          
          <category> 爱前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JavaScript复习</title>
      <link href="/a9840e73.html"/>
      <content type="html"><![CDATA[<p>[toc]</p><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h3 id="一、call和apply"><a href="#一、call和apply" class="headerlink" title="一、call和apply"></a>一、call和apply</h3><blockquote><p>call和apply是用来指定上下文运行函数的</p></blockquote><ul><li>我们写了一个函数，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此时如果要运行它，可以直接加圆括号运算符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn()</span><br></pre></td></tr></table></figure></p><p>此时函数的上下文就是window对象。所谓的上下文就是函数中出现的this是谁(此处指DOM开发中，node中的对象无法打印出来)。但很多时候我们需要让函数指定上下文运行，此时就要使用call和apply，它俩功能完全一样！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 改变某个值</span><br><span class="line">// fn是一个函数，功能是让上下文对象的a属性变为100，但这个函数到底给谁的a属性变为了100，此时不知道，要看函数调用时指定的上下文是谁</span><br><span class="line">function fn()&#123;</span><br><span class="line">    this.a = 100;</span><br><span class="line">&#125;</span><br><span class="line">var xiaoming = &#123;</span><br><span class="line">    a : 8,</span><br><span class="line">    b : 9</span><br><span class="line">&#125;</span><br><span class="line">// 此时想把xiaoming的a值变成100，思路是让xiaoming成为fn的this！</span><br><span class="line">//运行fn函数，同时指定xiaoming对象是fn函数的上下文</span><br><span class="line">fn.call(xiaoming);</span><br><span class="line">console.log(xiaoming); // &#123;a:100,b:9&#125;</span><br><span class="line"></span><br><span class="line">// fn.apply(xiaoming);</span><br><span class="line">// console.log(xiaoming);  // 结果和call是一样的</span><br></pre></td></tr></table></figure></p><blockquote><p>示例2：call和apply的区别(只有传参时有区别！ )</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// fn是一个函数，功能是让上下文对象的a属性变为传入的两个参数的和</span><br><span class="line">function fn(m,n)&#123;</span><br><span class="line">    this.a = m + n;</span><br><span class="line">&#125;</span><br><span class="line">var xiaoming = &#123;</span><br><span class="line">    a : 8,</span><br><span class="line">    b : 9</span><br><span class="line">&#125;</span><br><span class="line">// call规定第一个是上下文指定的对象，后面的是参数</span><br><span class="line">fn.call(xiaoming,2,3);</span><br><span class="line">console.log(xiaoming); // &#123;a:5,b:9&#125;</span><br><span class="line"></span><br><span class="line">// apply规定第一个是上下文指定的对象，后面用数组(或类数组的可枚举的形式)来传参</span><br><span class="line">// fn.apply(xiaoming,[2,3]);</span><br></pre></td></tr></table></figure><blockquote><p>示例3：call和apply的函数委托功能 – 假设有两个函数：厨师和服务员，服务员只负责把点的菜告诉厨师，厨师只负责根据传过来的菜单做菜，最初的思路可能是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function chushi()&#123;</span><br><span class="line">    for(var i=0; i&lt;arguments.length; i++)&#123;</span><br><span class="line">        console.log(arguments); // 4.此处将打印出1</span><br><span class="line">    // arguments是所有传入的实参列表，无视函数传进来多少参数</span><br><span class="line">        console.log(&quot;我是厨子，我要做&quot; + arguments[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fuwuyuan()&#123;</span><br><span class="line">    console.log(arguments); // 2.此处打印出3</span><br><span class="line">    chushi(arguments); // 3.但如果将arguments作为参数直接传给chushi的话，将作为一个整体而不会自动展开(es6中的三个点展开运算符就是为了解决这个问题而设计的)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuwuyuan(&quot;宫保鸡丁&quot;,&quot;鱼香肉丝&quot;,&quot;地三鲜&quot;); // 1.调用并传入菜单</span><br></pre></td></tr></table></figure><p>所以此时就要应用apply<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function chushi()&#123;</span><br><span class="line">    for(var i=0; i&lt;arguments.length; i++)&#123;</span><br><span class="line">    // arguments是所有传入的是参列表，无视函数传进来多少参数</span><br><span class="line">        console.log(&quot;我是厨子，我要做&quot; + arguments[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fuwuyuan()&#123;</span><br><span class="line">    chushi.apply(null, arguments); // 因为chushi里面没有出现this所以不需要指定上下文，设置为null就可以了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuwuyuan(&quot;宫保鸡丁&quot;,&quot;鱼香肉丝&quot;,&quot;地三鲜&quot;);</span><br></pre></td></tr></table></figure></p><blockquote><p>示例4：求和及平均值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function sum()&#123;</span><br><span class="line">    for(var i=0, _sum=0; i&lt;arguments.lenght; i++ )&#123;</span><br><span class="line">        _sum += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return _sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function average()&#123;</span><br><span class="line">    var _sum = sum.apply(null, arguments);</span><br><span class="line">    return _sum / arguments.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(average(4,4,4,5,5,5));</span><br></pre></td></tr></table></figure><blockquote><p>示例5：求最大值(Math.max)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.max(4,5,6,7,8)); // 当所有的数字是散点式(每个数字用逗号隔开)的时候，可以直接写</span><br><span class="line"></span><br><span class="line">// 但当传入的是一个数组时，就用apply</span><br><span class="line">var arr = [4,5,6,7,8];</span><br><span class="line">console.log(Math.max.apply(null, arr));</span><br></pre></td></tr></table></figure><h3 id="二、this"><a href="#二、this" class="headerlink" title="二、this"></a>二、this</h3><ol><li>this是什么？<blockquote><p>this就是函数的上下文。所以说，==函数的上下文，是除了参数之外的，最常用的使信息进入函数内部的手段==。</p></blockquote></li><li>this是谁？怎么判断？<blockquote><p>一定要死记：function定义的函数，this是谁，要看如何调用，而不是看如何定义！</p></blockquote></li></ol><ul><li><p>判断this的七个规则：</p><ul><li><p>规则1：函数直接用圆括号运行，上下文是window</p><blockquote><p>fn();     上下文是window</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a : 3,</span><br><span class="line">    fun : function()&#123;</span><br><span class="line">        var a = 5;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            alert(this.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fun()(); // undefined，因为最终调用函数(最后一个括号)的是window，而全局没有a这个变量</span><br></pre></td></tr></table></figure></li><li><p>规则2：对象打点调用函数，上下文是这个对象</p><blockquote><p>obj.fn();     上下文是obj</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a : 3,</span><br><span class="line">    fun : (function()&#123;</span><br><span class="line">        var a = 5;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            alert(this.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fun(); // 3，因为最终调用函数(最后一个括号)的是obj</span><br></pre></td></tr></table></figure></li><li><p>规则3：数组(类数组对象)中枚举出函数，上下文是这个数组</p><blockquote><p>arr<a href="">idx</a>;     上下文是arr</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn1(fn)&#123;</span><br><span class="line">    // 类数组对象中枚举出函数然后运行，上下文是这个类数组</span><br><span class="line">    arguments[0](3,4);</span><br><span class="line">&#125;</span><br><span class="line">function fn2()&#123;</span><br><span class="line">    // 也就是说fn2函数里的this居然是fn1的实际参数列表</span><br><span class="line">    alert(this.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1(fn2,5,6,7,8); // 所以弹出5(一共有5个实际参数)</span><br></pre></td></tr></table></figure></li><li><p>规则4：定时器调用函数，上下文是window</p></li><li>规则5：被当做了事件处理函数，上下文是触发事件的DOM元素</li><li><p>规则6：用new调用函数，上下文是函数体内秘密创建的空白对象</p><blockquote><p>用new调用函数会经过四步走：  </p><ul><li>秘密创建空对象  </li><li>将this绑定到这个空对象中  </li><li>执行语句  </li><li>返回这个对象</li></ul></blockquote></li><li><p>规则7：用apply、call指定上下文</p></li></ul></li></ul><ol><li>面试题举例<blockquote><p>第一道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    function getName()&#123;</span><br><span class="line">        alert(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = function()&#123;</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getName = function()&#123;</span><br><span class="line">    alert(3);</span><br><span class="line">&#125;</span><br><span class="line">var getName = function()&#123;</span><br><span class="line">    alert(4);</span><br><span class="line">&#125;</span><br><span class="line">function getName()&#123;</span><br><span class="line">    alert(5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">getName();</span><br><span class="line"></span><br><span class="line">//2</span><br><span class="line">Foo().getName();</span><br><span class="line"></span><br><span class="line">//3</span><br><span class="line">new Foo().getName();</span><br><span class="line"></span><br><span class="line">//4</span><br><span class="line">new Foo.getName();</span><br><span class="line"></span><br><span class="line">//5</span><br><span class="line">new new Foo().getName();</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p>解题思路：<br>1）首先排除123，不是4就是5；而函数的声明优先提升，所以先走5，然后提升变量的定义，走4，此时4会将5覆盖掉，所以答案是4<br>2）Foo()访问的是调用Foo的上下文，因为return的是this(与其内部闭包函数无关)，这里就是window，也就是相当于window.getName()，和1一样弹出4<br>3）记住new xxx()的优先级是非常高的！(注意是带括号的)一定要先完成new Foo()的部分，然后再去考虑getName()的部分！new Foo()是将第一个函数做了实例化，所以这道题的考点是原型链查找，对象能够沿着原型链，访问自己构造函数prototype上的属性和方法！所以这道题的答案是3<br>4）如果只是new，则优先级没那么高，所以这道题要先考虑后面Foo.getName()的部分，然后再考虑new！而后面就是一个函数，就相当于用new去调了一下这个函数，所以结果是2<br>5）优先级问题，首先看new Foo()部分，它返回一个对象Foo，然后这个对象打点调用了getName()，也就是通过原型链调用了自己构造函数的getName方法，最后还是用new调用了一下，相当于用new调普通函数，所以结果还是3</p></blockquote><hr><blockquote><p>第二道</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function getLength()&#123;</span><br><span class="line">    return this.length; // this未知，要看如何调用</span><br><span class="line">&#125;</span><br><span class="line">function foo()&#123;</span><br><span class="line">    this.length = 1; // this未知，要看如何调用</span><br><span class="line">    return (function()&#123;</span><br><span class="line">        var length = 2;</span><br><span class="line">        return &#123;</span><br><span class="line">            length: function(a,b,c)&#123;</span><br><span class="line">                return this.arr.length;</span><br><span class="line">            &#125;,</span><br><span class="line">            arr : [1,2,3,4],</span><br><span class="line">            info : function()&#123;</span><br><span class="line">                return getLength.call(this.length); //以this.length作为上下文调用getLength函数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line">var result = foo().info();</span><br><span class="line">alert(result);</span><br></pre></td></tr></table></figure><blockquote><p>解题思路：foo()适用于规则1，即被window调用，此时函数foo返回一个自执行函数，也就是说foo()就等同于</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    length: function(a,b,c)&#123;</span><br><span class="line">        return this.arr.length;</span><br><span class="line">    &#125;,</span><br><span class="line">    arr : [1,2,3,4],</span><br><span class="line">    info : function()&#123;</span><br><span class="line">        return getLength.call(this.length); //以this.length作为上下文调用getLength函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>foo().info()则符合规则2，即info中的this指的是对象本身，而对象本身的length是</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">length: function(a,b,c)&#123;</span><br><span class="line">    return this.arr.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>而这个小函数将被call指定为getLength的上下文传入，所以最终getLength得到的长度是这个小函数的长度，函数的长度为函数的形参列表的长度，小函数的形参列表是(a,b,c)，所以长度为3！(注意：函数的长度是形参列表的长度；arguments.length是函数实参列表的长度！arguments.callee表示函数本身，所以arguments.callee.length表示形参列表的长度！)</p></blockquote><hr><blockquote><p>第三题</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    this.a = 2;</span><br><span class="line">    function fn()&#123;</span><br><span class="line">        return this.a;</span><br><span class="line">    &#125;</span><br><span class="line">    fn.a = 3;</span><br><span class="line">    return fn;</span><br><span class="line">&#125;</span><br><span class="line">alert(fun()()); // fun()时，由于是被window调用，所以this.a=2就是在全局定义了一个变量a，fun()返回的是一个函数fn，fn再执行()的结果依旧是被window调用，此时全局的a为2</span><br></pre></td></tr></table></figure><blockquote><p>第四题</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fun()&#123;&#125;</span><br><span class="line">console.log(typeof fun); // function</span><br><span class="line">console.log(fun instanceof Function); // true</span><br><span class="line">console.log(fun instanceof Object); // true</span><br></pre></td></tr></table></figure><p><img src="img/aiqianduan/WX20200318-181513@2x.png" alt="wx20200222-213601@2x.png"></p><blockquote><p>第五题</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a : 2,</span><br><span class="line">    getA : function()&#123;</span><br><span class="line">        return this.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var getA = obj.getA;</span><br><span class="line">getA(); // 规则1，this是window，所以this.a是1</span><br></pre></td></tr></table></figure><blockquote><p>第六题</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2,</span><br><span class="line">    c:[&#123;</span><br><span class="line">      a:3,</span><br><span class="line">      b:4,</span><br><span class="line">      c:fn</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">    alert(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a=5;</span><br><span class="line">obj.c[0].c(); // obj.c[0]是&#123;a:3,b:4,c:fn&#125;这个对象！所以obj.c[0].c()适用规则2，而这个this代表的是这个对象，所以this.a是3！</span><br></pre></td></tr></table></figure><blockquote><p>第七题</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var number = 2;</span><br><span class="line">        var obj = &#123;</span><br><span class="line">            number : 4,</span><br><span class="line">            fn1: (function() &#123;</span><br><span class="line">                this.number *= 2;</span><br><span class="line">                number = number *2; // 局部变量number</span><br><span class="line">                var number = 3; // 此处声明提升，使局部变量number值为3</span><br><span class="line">                return function() &#123;</span><br><span class="line">                    this.number *= 2; // 此处this指的是全局的number，并且会把原来的2修改为4</span><br><span class="line">                    number *=3;</span><br><span class="line">                    alert(number);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)()</span><br><span class="line">        &#125;</span><br><span class="line">        alert(number); // 4</span><br><span class="line"></span><br><span class="line">        var fn1 = obj.fn1;</span><br><span class="line">        fn1(); // 9</span><br><span class="line">        obj.fn1(); // 27</span><br><span class="line">        alert(window.number); // 8</span><br><span class="line">        alert(obj.number); // 8</span><br></pre></td></tr></table></figure><h3 id="三、算法类"><a href="#三、算法类" class="headerlink" title="三、算法类"></a>三、算法类</h3><ol><li>数组的相关算法</li></ol><blockquote><p>数组去重：最简单的方法就是ES6中的Set数据结构。Set说白了就是不能有重复项的数组。用数组来构建Set，数组会自动去重</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,1,1,1,2,2,2,2,3,3,3,3];</span><br><span class="line"></span><br><span class="line">const set = new Set(arr);</span><br><span class="line">console.log([...set]); // 三个.是ES6的强制结构的运算符，直接输出set的话是一个对象</span><br></pre></td></tr></table></figure><p>传统方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,1,1,1,2,2,2,2,3,3,3,3];</span><br><span class="line">var _result = [];</span><br><span class="line">function uniq(arr)&#123;</span><br><span class="line">    for(var i = 0; i &lt; arr.lenght; i++)&#123;</span><br><span class="line">        if(!_result.includs(arr[i]))&#123; // includs用到的是===，即如果数组中有&quot;1&quot;也会被保留下来</span><br><span class="line">            _result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">        return _result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniq(arr));</span><br></pre></td></tr></table></figure></p><blockquote><p>如何看数组的时间复杂度：时间复杂度用o()来表示，n表示数组的长度。那么这个例子中的算法的时间复杂度即为o(n)，表示时间复杂度随着数组长度线性变化</p></blockquote><ol><li>数组排序</li></ol><blockquote><p>冒泡排序：5个球进行排序，需要比较4趟，共比较次数4+3+2+1=10次。也就是说，长度为n的数组进行冒泡，共需要比较n-1趟，共比较<img src="img/aiqianduan/WX20200318-181532@2x.png" alt="wx20200225-183922@2x.png">次</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// bubbleSort不是纯函数，不是pure的，因为我们改变了传入到它内部的参数的值</span><br><span class="line">function bubbleSort(arr)&#123;</span><br><span class="line">    for(let i =0; i&lt; arr.length - 1; i++)&#123;</span><br><span class="line">        for(let j = 0; j&lt;arr.length - 1 - i; j++)&#123;</span><br><span class="line">            if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                // 交换数字的位置，需要引入第三方变量做周转</span><br><span class="line">                var temp = arr[i];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [7,3,5,9,10,56,33,6];</span><br><span class="line">console.log(bubbleSort(arr));</span><br></pre></td></tr></table></figure><blockquote><p>纯函数写法：浅克隆</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr)&#123;</span><br><span class="line">    // 先浅克隆数组</span><br><span class="line">    var _arr = [].concat(arr);</span><br><span class="line"></span><br><span class="line">    for(let i =0; i&lt; arr.length - 1; i++)&#123;</span><br><span class="line">        for(let j = 0; j&lt;_arr.length - 1 - i; j++)&#123;</span><br><span class="line">            if(_arr[j] &gt; _arr[j+1])&#123;</span><br><span class="line">                // 交换数字的位置，需要引入第三方变量做周转</span><br><span class="line">                var temp = _arr[i];</span><br><span class="line">                _arr[j] = _arr[j + 1];</span><br><span class="line">                _arr[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return _arr;</span><br><span class="line">&#125;</span><br><span class="line">const arr = [7,3,5,9,10,56,33,6];</span><br><span class="line">var result = bubbleSort(arr)</span><br><span class="line">console.log(arr); // 数组不变</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><blockquote><p>快速排序（二分法排序）思路：选择数组的第0项作为标杆，比他大的放一起，小的放一起，然后再用递归分别排两边的数组，直到顺序正确</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr)&#123;</span><br><span class="line">    // 停止递归的条件</span><br><span class="line">    if(arr.length &lt;=1)&#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    // 标杆</span><br><span class="line">    const pivot = arr[0];</span><br><span class="line">    // 比标杆大的</span><br><span class="line">    var bigger = [];</span><br><span class="line">    // 比标杆小的</span><br><span class="line">    var smaller = [];</span><br><span class="line">    </span><br><span class="line">    // 遍历，区分大小</span><br><span class="line">    for(let i=1; i &lt; arr.length; i++)&#123;</span><br><span class="line">        if(arr[i] &gt;= pivot)&#123; // &gt;=时，i从1开始，&gt;时i从0开始</span><br><span class="line">            bigger.push(arr[i]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            smaller.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return quickSort(smaller).concat(pivot, quickSort(bigger)); // 运用递归，是两个数组完成排序，注意要有递归停止条件(最上)</span><br><span class="line">&#125;</span><br><span class="line">var arr = [56,332, 24,64,3,45,12,456,88,99,32];</span><br><span class="line">console.log(quickSort(arr));</span><br></pre></td></tr></table></figure><p>冒泡排序的时间复杂度是o((n²-n)/2)，快速排序的时间复杂度是o(nlogn)，比冒泡排序快很多</p><blockquote><p>let和var的区别：let表示块级作用域，在for循环中有奇效，它可以自动创建闭包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">    arr[i] = function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[5](); // 输出10，因为i是用var声明的全局变量，循环体走完后值为10</span><br><span class="line"></span><br><span class="line">// 如果想每次输出i的值，传统做法(ise)：</span><br><span class="line">for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">    function(i)&#123; // 此时i为局部变量</span><br><span class="line">        arr[i] = function()&#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新办法(用let)：</span><br><span class="line">for(let i = 0; i &lt; 10; i++)&#123; // let创建了一个小的闭包，使i只在本次循环生效</span><br><span class="line">    arr[i] = function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>递归：面试大致只有6种递归题型：</li></ol><ul><li>阶乘(n!)</li><li>数组扁平化</li><li>深克隆</li><li>数组的快速排序</li><li>杨辉三角等数学模型的建立</li><li>脑筋急转弯，比如不用while、for等输出1、2、3……100<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 数组扁平化</span><br><span class="line">var arr = [[1,2,3],[4,[[[[5,6],7,8]]],9],10];</span><br><span class="line">function flattenArray(arr)&#123;</span><br><span class="line">    var _arr = [];</span><br><span class="line">    // 每一项进行遍历，看看是常数还是数组</span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        // 数组的识别用isArray，typeof结果是object</span><br><span class="line">        if(!Array.isArray(arr[i]))&#123;</span><br><span class="line">            _arr.push(arr[i]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 如果这项是数组，那么重复这次的遍历模式(递归)</span><br><span class="line">            _arr = _arr.concat(flattenArray(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return _arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(flattenArray(arr));</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>拓展功能：想都不要想，一定是用prototype</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 求数组最大值</span><br><span class="line">Array.prototype.max = function()&#123;</span><br><span class="line">    // return Math.max.apply(null, this);</span><br><span class="line">    return Math.max(...arr);</span><br><span class="line">&#125;</span><br><span class="line">var arr = [343,23,478,980];</span><br><span class="line">console.log(arr.max()); // 注意是arr.max()</span><br></pre></td></tr></table></figure><blockquote><p>函数的柯里化：函数少穿一个实参就会返回另一个函数，这个函数虚位以待，等待你随时传入最后的参数！假设有一个函数功能是求传入四个参数的和，可如果只传入三个函数，则返回NaN(undefined加任何数都是NaN)，此时为避免这种情况，就需要让函数返回另一个把现有参数先加完，并随时准备接受剩余参数继续相加的函数，这个过程就叫做函数的柯里化(发明此种功能的人叫做柯里curry)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        // 备份实参</span><br><span class="line">        var args = arguments;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return fn(...args, ...arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun(a,b,c,d)&#123;</span><br><span class="line">    return a+b+c+d;</span><br><span class="line">&#125;</span><br><span class="line">// 柯里化</span><br><span class="line">fun = curry(fun);</span><br><span class="line"></span><br><span class="line">var fn = fun(1,2);</span><br><span class="line">console.log(fn(3,4));</span><br></pre></td></tr></table></figure><blockquote><p>深浅克隆：首先要区分基本类型值和引用类型值，如下例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型值：在内存中拷贝了一份，所以源数据改变时它不跟着变</span><br><span class="line">var a = 3;</span><br><span class="line">var b = a;</span><br><span class="line"></span><br><span class="line">a++;</span><br><span class="line">console.log(b); // 3</span><br><span class="line"></span><br><span class="line">// 引用类型值：在内存中共用一片堆内存，所以源数据改变时它跟着变</span><br><span class="line">var a = [1,2,3,4];</span><br><span class="line">var b = a;</span><br><span class="line"></span><br><span class="line">a.push(5);</span><br><span class="line">console.log(b); // [1,2,3,4,5]</span><br></pre></td></tr></table></figure><p>基本类型值：</p><ul><li>种类：number、string、boolean、undefined</li><li>特点：做变量传值的时候，内存中会复制一份。在做==判断或===判断时，仅比较值是否相当<br><img src="img/aiqianduan/WX20200318-181548@2x.png" alt="wx20200306-095640@2x.png"><br>引用类型值：</li><li>种类：function、object、array、regexp、null</li><li>特点：做变量传值的时候，内存中不会复制。在做==判断或===判断时，要看是否是内存中的同一个对象。<br><img src="img/aiqianduan/WX20200318-181558@2x.png" alt="wx20200306-095835@2x.png"><br>所以有经典面试题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] == [] // false</span><br><span class="line">&#123;&#125; == &#123;&#125; // false</span><br><span class="line">[1] == [1] // false</span><br></pre></td></tr></table></figure></li></ul><p>那么如何复制一个数组(对象)呢？</p><blockquote><p>浅克隆：只表层克隆一层，如果数组的某项也是数组，这个内层数组还是内存中的同一对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,[55,66,77]];</span><br><span class="line">var _arr = [];</span><br><span class="line">for(let i = 0; i&lt;arr.length; i++)&#123;</span><br><span class="line">    _arr.push(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(_arr == arr); // false，克隆成功，现在arr和_arr已经是两个对象了</span><br><span class="line">console.log(_arr[4] == arr[4]); // true，但是它们的第四项内部数组还是同一个</span><br></pre></td></tr></table></figure><blockquote><p>关于const：定义常量时，值不能改！但定义对象的话，其属性值可以改</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    const ceshi = &#123;</span><br><span class="line">        name: &apos;a&apos;,</span><br><span class="line">        age: 1</span><br><span class="line">    &#125;</span><br><span class="line">    ceshi.name = &apos;b&apos;</span><br><span class="line">    return ceshi</span><br><span class="line">&#125;</span><br><span class="line">console.log(fn()) // b</span><br></pre></td></tr></table></figure><blockquote><p>补充一点关于arguments的知识</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn(a,b)&#123;</span><br><span class="line">    console.log(a === arguments[0]); // true</span><br><span class="line">    console.log(b === arguments[1]); // true</span><br><span class="line">    a = 123;</span><br><span class="line">    b = 456;</span><br><span class="line">    console.log(a === arguments[0]); // true</span><br><span class="line">    console.log(b === arguments[1]); // true</span><br><span class="line">&#125;</span><br><span class="line">fn(3,4);</span><br></pre></td></tr></table></figure><blockquote><p>arguments表示实参类数组对象，它总是能跟着具名形参的变化而变化。当a、b重新赋值的时候，arguments[0]和arguments[1]也就同步更新 了。但是在严格模式下就不会这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn(a,b)&#123;</span><br><span class="line">    &quot;use strict&quot;</span><br><span class="line">    console.log(a === arguments[0]); // true</span><br><span class="line">    console.log(b === arguments[1]); // true</span><br><span class="line">    a = 123;</span><br><span class="line">    b = 456;</span><br><span class="line">    console.log(a === arguments[0]); // false</span><br><span class="line">    console.log(b === arguments[1]); // false</span><br><span class="line">&#125;</span><br><span class="line">fn(3,4);</span><br></pre></td></tr></table></figure><blockquote><p>如果函数有默认参数，那么默认参数不算arguments的length。你传入了几个实参，长度就是几。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn(a, b=3)&#123;</span><br><span class="line">    console.log(arguments.length);</span><br><span class="line">&#125;</span><br><span class="line">fn(333); // 答案是1，因为只传了一个参数</span><br></pre></td></tr></table></figure><blockquote><p>同时，当参数有默认值时，改变a和b的值，不会对arguments造成影响，并且不能进入严格模式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn(a, b=3)&#123;</span><br><span class="line">    console.log(arguments.length); // 1，因为只传了一个参数</span><br><span class="line">    console.log(a === arguments[0]); // true</span><br><span class="line">    console.log(b === arguments[1]); // false，因为arguments[1]是undefined</span><br><span class="line">    a = 123;</span><br><span class="line">    b = 456;</span><br><span class="line">    console.log(a === arguments[0]); // false，注意这里不会变</span><br><span class="line">    console.log(b === arguments[1]); // false，注意这里不会变</span><br><span class="line">&#125;</span><br><span class="line">fn(333);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端知识 </category>
          
          <category> 笔记 </category>
          
          <category> 爱前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>AE的菜单方面的中英文对照</title>
      <link href="/a511212d.html"/>
      <content type="html"><![CDATA[<p>File菜单<br>新建 ← New<br>┗New Project → 新建项目<br>New Folder →新建文件夹<br>打开项目 ← Open Project<br>打开最近项目 ← Open Recent Projects<br>关闭 ← Close<br>保存 ← Save<br>另存为 ← Save As…<br>保存副本 ← Save a Copy…<br>恢复 ← Revert<br>导入 ← Import<br>┗File… → 文件<br>Multiple Files… →多个文件<br>Placeholder… →输入占位符<br>Solid… →实色<br>导入最近镜头 ← Import Recent Footage<br>输出 ← Export<br>查找 ← Find…<br>再次查找 ← Find Next<br>添加镜头到合成 ← Add Footage to Comp<br>选定脚本建立合成 ← New Comp From Selection…<br>整理镜头 ← Consolidate All Footage<br>删除未用镜头 ← Remove Unused Footage<br>简化项目 ← Reduce Project<br>文件打包 ← Collect Files…<br>浏览文件夹 ← Watch Folder…<br>运行脚本 ← Run Script<br>建立代理 ← Create Proxy<br>┗Still… → 静态图片<br>Movie… → 影片<br>设置代理 ← Set Proxy<br>┗File… → 文件<br>None →无<br>解释镜头 ← Interpret Footage<br>┗Main… → 常规<br>Proxy… → 代理<br>Remember Interpretation →保存解释<br>Apply Interpretation →应用解释<br>替换镜头 ← Replace Footage<br>┗File… → 文件<br>Placeholder… → 占位符<br>Solid.. → 实色<br>重载镜头 ← Reload Footage<br>显示所在文件夹 ← Reveal in Explorer<br>项目设置 ← Project Settings…<br>打印 ← Print…<br>退出 ← Exit<br>Edit菜单<br>撤消 ← Undo Copy<br>重复 ← Redo Copy<br>历史记录 ← History<br>剪切 ← Cut<br>复制 ← Copy<br>粘贴 ← Paste<br>清楚 ← Clear<br>副本 ← Duplicate<br>分层图层 ← Split Layer<br>抽出工作区域 ← Lift Work Area<br>挤压工作区域 ← Extrace Work Area<br>选择全部 ← Select All<br>全部取消 ← Deselect All<br>标签 ← Label<br>清空 ← Pruge<br>┗All → 全部<br>Undo → 撤消<br>Image Caches → 图象缓存<br>Snapshot → 快照<br>Video Memory → 视频内存<br>编辑原稿 ← Edit Original<br>模版 ← Templates<br>┗Render Settings… → 渲染设置<br>Output Module… → 输出模式<br>预置 ← Preferences<br>┗General… → 常规<br>Previews… → 预演<br>Display → 显示<br>Import… → 输入<br>Output → 输出<br>Grids &amp; Guides… → 辅助线及网络<br>Label Colors… → 标签颜色<br>Label Defaults… → 标签设置<br>Cache… → 缓存<br>Video Preview… → 视频预演<br>Animation菜单<br>添加关键帧 ← Add Keyframe<br>冻结关键帧 ← Toggle Hold Keyframe<br>关键帧插值 ← Keyframe Interpolation…<br>关键帧速率 ← Keyframe Velcity…<br>辅助关键帧 ← Keyframe Assistant<br>┗Convert Audio to Keyframes → 转换音频为关键帧<br>Convert Expression to Keyframes → 转换表达式为关键帧<br>Easy Ease → 缓和曲线<br>Easy Ease In → 缓和曲线进入<br>Easy Ease Out → 缓和曲线离开<br>Exponential Scale → 指数缩放<br>RPF Camera Import → RPF摄象机导入<br>Sequence Layers… → 图层排序<br>Time-Reverse Keyframes → 反转关键帧<br>文字动画 ← Animate Text<br>┗Anchor Point → 轴心点<br>Position → 位置<br>Scale → 缩放<br>Skew → 倾斜<br>Rotation → 旋转<br>Opacity → 不透明度<br>All Transform → 所有变换<br>Fill Color → 填充色<br>Stroke Color → 描边色<br>Stroke Width → 描边宽度<br>Tracking → 追踪<br>Line Anchor → 线形频谱<br>Line Spacing → 线形间距<br>Character Offset → 字符位移<br>Character Value → 字符值率<br>添加文字选择器 ← Add Text Selector<br>┗Range → 平行<br>Wiggly → 抖动<br>移除所有文字动画 ← Remove All Text Animators<br>添加表达式 ← Add Expression<br>追踪运动 ← Track Motion<br>稳定运动 ← Stabilize Motion<br>追踪当前属性 ← Track this property<br>显示关键帧 ← Reveal Animating Properties<br>显示被修改属性 ← Reveal Modified Properties<br>View菜单<br>新视图 ← New View<br>放大 ← Zoom In<br>缩小 ← Zoom Out<br>解析度 ← Resolution<br>┗Full → 最佳<br>Half → 一半<br>Third → 三分之一<br>Quarter → 四分之一<br>Custom…. → 自定义<br>隐藏/显示标尺 ← Show Rulers<br>隐藏/显示辅助线 ← Hide Guides<br>吸附辅助线 ← Snap To Guides<br>锁定辅助线 ← Lock Guides<br>清楚辅助线 ← Clear Guides<br>隐藏/显示网格 ← Show Grid<br>吸附网格 ← Snap to Grid<br>视图选项 ← View Options…<br>显示图层控制 ← Hide Layer Controls<br>重置3D视图 ← Reset 3D View<br>切换3D视图 ← Switch 3D View<br>┗Active Camera → 当前摄象机<br>Front → 前视图<br>Left → 左视图<br>Top → 顶视图<br>Back → 后视图<br>Right → 右视图<br>Bottom → 底视图<br>Custom View 1 → 自定视图1<br>Custom View 2 → 自定视图2<br>Custom View 3 → 自定视图3<br>快速设置3D窗口 ← Set 3D View Shortcut<br>┗Replace “Front” → 替换为前视图<br>Replace “Custom View 1” → 替换为自定视图1<br>Replace “Active Camere” → 替换为动态摄象机<br>切换到最近的3D视图 ← Switch To Last 3D View<br>观察选择图层 ← Look At Selected Layers<br>观察所有图层 ← Look At All Layers<br>前往指定时间 ← Go To Time…</p><p>Layer菜单<br>新建 ← New<br>┗Text → 文字<br>Solid… → 实色<br>Light… → 灯光<br>Camera.. → 摄象机<br>Null Object → 虚拟对象<br>Adjustment Layerv → 调节层<br>层设置 ← Layer Settings…<br>打开层窗口 ← Open Layer Window<br>打开素材窗口 ← Open Source Window<br>遮罩 ← Mask<br>┗New Mask → 新建遮罩<br>Mask Shape → 遮罩形状<br>Mask Feather → 遮罩羽化<br>Mask Opacity → 遮罩不透明度<br>Mask Expansion → 遮罩伸缩<br>Reset Mask → 重置遮罩<br>Remove Mask → 删除遮罩<br>Remove All Masks → 删除所有遮罩<br>Mode →模式<br>┗None → 无<br>Add → 相加<br>Subtrace → 相减<br>Intersect → 交集<br>Lighten → 变亮<br>Darken → 变暗<br>Difference → 差值<br>RotoBezier → 旋转式曲线<br>Inverse → 反转<br>Closed → 封闭<br>Set First Vertex → 设置起始点<br>Locked → 锁定<br>Motion Blur → 运动模糊<br>┗Same As Layer → 与层相同<br>On → 开<br>Off → 关<br>Unlock All Maskss → 解锁所有遮罩<br>Lock Other Masks → 锁定其他遮罩<br>Free Transform Points → 自由变换点<br>质量 ← Quality<br>┗Best → 最佳<br>Draft → 草图<br>Wireframe → 线框<br>转换开关 ← Switches<br>┗Hide Other Video → 隐藏其他视频层<br>Show All Video → 显示所有视频层<br>Unlock All Layers → 解锁所有层<br>Shy → 退缩<br>Lock → 锁定<br>Audio → 音频<br>Videl → 视频<br>Solo → 独奏<br>Effect → 特效<br>Collapse → 卷展<br>Frame Blending → 帧融合<br>Motion Blur → 运动模糊<br>Adjustment Layer → 调节层<br>变换 ← Transform<br>┗Reset → 复位<br>Anchor Point → 定位点<br>Position → 位置<br>Scale → 缩放<br>Orientation → 方向<br>Rotation → 旋转<br>Opacity → 不透明度<br>Auto-Orient → 自动定向<br>三维层 ← 3D Layer<br>添加标记 ← Add marker<br>保持透明 ← Presserve Transparency<br>混合模式 ← Blending Mode<br>┗Normal → 正常<br>Dissolve → 溶解<br>Dancing Dissolve → 动态溶解<br>Daiken → 变暗<br>Multiply → 正片叠底<br>Linear Burn → 线性加深<br>Color Burn → 颜色加深<br>Classic Color Burn → 典型颜色加深<br>Add → 加<br>Lighten → 变亮<br>Screen → 屏幕<br>Linear Dodge → 线性减淡<br>Color Dodge → 颜色减淡<br>Classic Color Dodge → 典型颜色减淡<br>Overlay → 叠加<br>Soft Light → 柔光<br>Hard Light → 强光<br>Linear Light → 线性光<br>Vivid light → 艳光<br>Pin Light → 点光<br>Hard Mix → 强烈混合<br>Difference → 差值<br>Classic Difference → 典型差值<br>Exclusion → 排除<br>Hue → 色相合成<br>Sateration → 饱和度<br>Color → 颜色<br>Luminosity → 亮度<br>Stencil Alpha → Alpha模版<br>Stencil Luma → 亮度模版<br>Silhouette Alpha → Alpha轮廓<br>Silhouette Luma → 亮度轮廓<br>Alpha Add → Alpha添加<br>Luminescent Premul → 冷光<br>下一个混合模式 ← Next Blending Mode<br>上一个混合模式 ← Previous Blending Mode<br>轨道蒙版 ← Track Matte<br>┗No Track Matte → 无<br>Alpha Matte → Alpha蒙版<br>Alpha Inverted Matte → 反相Alpha蒙版<br>Luma Matte → 亮度蒙版<br>Luma Inverted Matte → 反相亮度蒙版<br>图层置顶 ← Bring Layer to Front<br>图层置上 ← Bring Layer Forward<br>图层置下 ← Send Layer Backward<br>图层置底 ← Send Layer to Back<br>转换为可编辑文本 ← Convert To Editable Text<br>创建轮廓 ← Create Outlines<br>自动追踪 ← Auto-trace…<br>激活时间变速 ← Enable Time Remapping<br>时间伸缩 ← Time Stretch…<br>重组 ← Pre-compose…</p><p>Effect菜单<br>特效控制 ←Effect Controls<br>上一个特效 ←Reduce Interlace Flicker<br>全部删除 ←Remove All<br>有储收藏 ←Save Favorite<br>应用收藏 ←Apply Favorite<br>最近收藏 ←Recent Favorites<br>三维通道 ←3D Channel<br>┗3D Chaccel Extract →提取三维通道<br>Depth Matte →深度蒙版<br>Depth of Field →场深度<br>Fog 3D →雾化<br>ID Matte →ID蒙版<br>调整 ←Adjust<br>┗Brightness &amp; Contrast →亮度和对比度<br>Channel Mixer →通道混合<br>Color Balance →色彩平衡<br>Color Stabilizer →色彩平衡器<br>Curves →曲张<br>Hue/Saturation →色相/饱和度<br>Levels →色阶<br>Levels(Individual Controls) →色阶(个体控制)<br>Posterize →色调分离<br>Threshold →阈值<br>音频 ←Audio<br>┗Backwards →倒播<br>Bass &amp; Treble →低音和高音<br>Delay →延迟<br>Flange &amp; Chorus →变调和合声<br>High-Low Pass →高低音过滤<br>Modulator →调节器<br>Parametric EQ →EQ参数<br>Reverb →回声<br>Stereo Mixer →立体声混合<br>Tone →音质<br>模糊与锐化 ←Blur &amp; Sharpen<br>┗Channel Blur →通道模糊<br>Comound Blur →混合模糊<br>Direction Blur →方向模糊<br>Fast Blur →快速模糊<br>Gaussian Blur →高斯式模糊<br>Radial Blur →径向模糊<br>Sharpen →锐化<br>Unsharp Mask →反遮罩锐化<br>通道 ←Channel<br>┗3D Glasses →三维眼睛<br>Alpha Levels →Alpha色阶<br>Arithmetic →运算<br>Blend →混合<br>Calculations →计算<br>Channel Combiner →通道组合<br>Cineon Converter →转换Cineon文件<br>Compound Arithmetic →复合计算<br>Invert →反相<br>Minimax →扩亮扩暗<br>Remove Color Matting →删除蒙版颜色<br>Set Channels →设置通道<br>Set Matte →设置蒙版<br>Shift Channels →转换通道<br>Solid Composite →实色合成<br>扭曲 ←Distort<br>┗Bezier Warp →贝塞尔曲线弯曲<br>Bulge →凹凸镜<br>Corner Pin →边角定位<br>Displacement Map →置换<br>Liquify →液化<br>Magnify →放大<br>Mesh Warp →网格变形<br>Mirror →镜像<br>Offset →位移<br>Optics Compensation →镜头变形<br>Polar Coordinates →极坐标转换<br>Reshape →形变<br>Ripple →波纹<br>Smear →涂抹<br>Spherize →球面化<br>Transform →变换<br>Turbulent Displace →剧烈置换<br>Twirl →扭转<br>Warp →弯曲<br>Wave Warp →波浪变形</p><p>表达式控制 ←Expression Controls<br>┗Angle Control →角度控制<br>Checkbox Control →检验盒控制<br>Color Control →色彩控制<br>Layer Control →层控制<br>Point Control →点控制<br>Slider Control →游标控制<br>图象控制 ←Image Control<br>┗Change Color →转换色彩<br>Change To Color →定向转换色彩<br>Color Balance(HLS) →色彩平衡<br>Color Link →色彩连接<br>Colorama →彩光<br>Equallize →均衡<br>Gamma/Pedestal/Gain →伽玛/基色/增益<br>Grow Bounds →增长边缘<br>PS Arbitrary Map →映象<br>Tint →色彩<br>键控 ←Keying<br>┗Color Difference Key →色彩差异键<br>Color Key →色彩键<br>Color Range →色彩范围<br>Difference Matte →差异蒙版<br>Extrace →提取<br>Inner/Outer Key →轮廓键<br>Keylight →光键<br>Linear Color Key →线性色彩键<br>Luma Key →亮度键<br>Spill Suppressor →溢色抑制<br>蒙版工具 ←Matte Tools<br>┗Matte Choker →蒙版清除<br>Simple Choker →简单清除<br>杂色 ←Noise<br>绘画 ←Paint<br>透视 ←Perspective<br>渲染 ←Render<br>仿真 ←Simulation<br>风格化 ←Stylize<br>文字 ←Text<br>时间 ←Time<br>切换 ←Transition<br>视频 ←Video</p><p>Compostion菜单<br>新建合成 ←New Composition<br>合成设置 ←Compodition Settings<br>背景颜色 ←Background Color<br>设置海报 ←Set Poster Time<br>修剪合成适配工作区域 ←Trim Comp to Work Area<br>裁切合成适配自定区域 ←Crop Comp to Region of Interest<br>增加到渲染序列 ←Add To Render Queue<br>添加输出模块 ←Add Output Module<br>预演 ←Preview<br>┗RAM Preview →内存预演<br>Wireframe Preview →线框预演<br>Motion with Trails →运动轨迹<br>Audio →音频<br>Audio Preview(Here Forward) →音频预演(当前位置)<br>Audio Preview(Work Area) →音频预演(工作区域)<br>存储单帧为 ←Save Frame As<br>┗File →文件<br>Photoshop Layers →Photoshop图层<br>制作影片 ←Make Movie<br>组合渲染 ←Pre-render<br>存储内存预演 ←Save RAM Preview<br>观察流程图 ←Comp Flowchart View</p><p>Window菜单</p><p>工作空间 ←Workspace<br>┗One Comp View →单视图<br>Two Comp View →双视图<br>Four Comp View →四视图<br>Conform All Windows →适应窗口<br>Save Workspace →存储工作空间<br>Delete Workspace →删除工作空间<br>层叠 ←Cascade<br>拼贴 ←Tile<br>排列图标 ←Arrange Icons<br>全部关闭 ←Close All<br>全组关闭 ←Closing in Groups<br>工具箱 ←Tools<br>信息调板 ←Info<br>时间控制调板 ←Time Controls<br>音频调板 ←Audio<br>特效调板 ←Effects<br>字符调板 ←Character<br>段落调板 ←Paragraph<br>绘画调板 ←Paint<br>笔刷技巧调板 ←Brush Tips<br>运动草图 ←Motion Sketch<br>智能遮罩插值 ←Smart Mask Interpolation<br>平滑 ←The Smoother<br>抖动 ←The Wiggler<br>对齐和分布 ←Align &amp; Distribute<br>追踪控制 ←Tracker Controls<br>立方体建立 ←Box Creator Lite<br>立体散布 ←Cubic Distribution Light<br>圆柱体建立 ←Cylinder Creator Lite<br>当前文件 ←Untitled Project.aep*<br>项目流程图 ←Project Flowchart View<br>渲染序列 ←Render Queue<br>重置调板位置 ←Reset Palette Locations</p><p>Help菜单</p><p>关于AfferEffects ←About After Effects<br>AfferEffects帮助 ←After Effects Help<br>特效帮助 ←Effects Help<br>脚本帮助 ←Scripting Help<br>每日技巧 ←Tip og the Day<br>注册 ←Registration<br>3D Channel (3D通道)<br>3D Channel Extract———3D通道扩展<br>Depth Matte—————-深厚粗糙<br>Depth of Field————-深层画面<br>Fog 3D———————3D 雾化<br>ID Matte——————-ID 粗糙<br>Adjust (调整)<br>Brightness &amp; Contrast———-亮度与对比度<br>Channel Mixer——————通道混合器<br>Color Balance——————色彩平衡<br>Color Stabilizer—————色彩稳压器<br>Curves————————-曲线<br>Hue/Saturation—————–色饱和<br>Levels————————-色阶<br>Levels (Individual Controls)—色阶 (分色RGB的控制)<br>posterize———————-色调分离<br>Threshold———————-阈值<br>Audio (音频)<br>Backwards—————向后<br>Bass &amp; Treble———–低音与高音<br>Delay——————-延迟<br>Flange &amp; Chorus———边缘与合唱团<br>High-Low Pass———–高音/低音<br>Modulator—————调幅器<br>Parametric EQ———–EQ参数<br>Reverb——————回音<br>Stereo Mixer————立体声混合器<br>Tone——————–音调<br>Blur &amp; Sharpen (模糊与锐化)<br>Clannel Blur—————通道模糊<br>Compound Blur————–复合的模糊<br>Directional Blur———–方向性的模糊<br>Fast Blur——————快污模糊<br>Gaussian Blur————–高斯模糊<br>Radial Blur—————-径向模糊<br>Sharpen——————–锐化<br>Unsharp Mask—————锐化掩膜<br>Channel (通道)<br>Alpha Levels——————-ALPHA 层通道<br>Arithmetic———————运算<br>Bland————————–柔化<br>Cineon Converter—————间距转换器<br>Compound Arithmetic————复合运算<br>Invert————————-反向<br>Minimax————————像素化<br>Remove Color Matting———–去除粗颗粒颜色<br>Set Channels——————-调节通道<br>Set Matte———————-调节粗糙度<br>Shift Channels—————–转换通道<br>Distort (变型)<br>Bezier Warp—————-Bezier 变型<br>Bulge———————-鱼眼<br>Displacement Map———–画面偏移<br>Mesh Warp——————网状变形<br>Mirror———————镜像<br>Offset———————偏移量<br>Optics Compensation——–光学替换 (可制作球体滚动效果)<br>Polar Coordinates———-极坐标<br>Reshape——————–重塑<br>Ripple———————涟漪<br>Smear———————-涂片<br>Spherize——————-球型变形<br>Transform——————变换<br>Twirl———————-旋转变形<br>Wave Warp——————波型变形<br>Expression Controls (表达式控制)<br>Angle Control————角度控制<br>Checkbox Control———复选框控制<br>Color Control————颜色控制<br>Layer Control————图层控制<br>Point Control————锐化控制<br>Slider Control———–滑块控制<br>Image Control (图像控制)<br>Chaner Color——————-改变颜色<br>Color Balance (HLS)————色彩平衡 (HLS)<br>Colorama———————–着色剂<br>Equalize———————–平衡<br>Gamma/Pedestal/Gain————GAMMA/电平/增益<br>Median————————-中线<br>PS Arbitrary MapPS————-任意的映射<br>Tint—————————去色<br>Keying (键控制)<br>Color Difference Key———–差异的色键<br>Color Key———————-色键<br>Color Range——————–色键幅度<br>Difference Matte—————不同粗粗糙 (以粗颗粒渐变到下一张图)<br>Extract————————扩展<br>Inner Outer Key—————-内部、外部色键<br>Linear Color Key—————线性色键<br>Luma Key———————–LUMA键<br>Spill Suppressor—————溢出抑制器<br>Matte Tools (粗糙工具)<br>Matte Cloker————-粗糙 窒息物 <em><br>Simple Choker————简单的 窒息物 </em><br>Paint (油漆)<br>Vector Paint————矢量油漆<br>Perspective (透视)<br>Basic 3D—————–基本的3D<br>Bevel Alpha————–倾斜 ALPHA<br>Bevel Edges————–倾斜边<br>Drop Shadow————–垂直阴影<br>Render (渲染)<br>4-Color Gradient———–4色 倾斜度<br>Advanced Lightning———高级闪电<br>Audio Spectrum————-音频光谱<br>Audio Waveform————-音频波形<br>Beam———————–射线<br>Cell Pattern—————单元模式<br>Ellipse——————–椭圆<br>Fill———————–填充<br>Fractal——————–分数维<br>Fractal Noise————–粗糙的分数维<br>Grid———————–网格<br>Lens Flare—————–镜头光晕<br>Lightning——————闪电<br>Radio Waves—————-音波<br>Ramp———————–斜面<br>Stroke———————笔划 (与stylize-write on功能类似)<br>Vegas———————-维加斯<br>Simulation (模拟)<br>Particle Playground————粒子运动场<br>Shatter————————粉碎<br>Stylize (风格化)<br>Brush Strokes————-笔刷<br>Color Emboss————–颜色浮雕<br>Emboss——————–浮雕<br>Find Edges—————-查找边缘<br>Glow———————-照亮边缘<br>Leave Color—————离开颜色<br>Mosaic——————–马赛克<br>Motion Tile—————运动平铺<br>Noise———————噪音<br>Roughen Edges————-变粗糙边<br>Scatter——————-分散<br>Strobe Light————–匣门光 <em><br>Texturize—————–基底凸现<br>Write-on——————在…..上写 (与render-stroke功能类似)<br>Text (文本)<br>Basic Text—————基本的文本<br>Numbers——————数字文本<br>Path Text—————-路径文本<br>Time (时间)<br>Echo———————-回响<br>Posterize Time————发布时间<br>Time Difference———–时间差别 </em><br>Time Displacement———时间偏移<br>Transition (转场)<br>Block Dissolve———-块溶解<br>Gradient Wipe———–斜角转场<br>Iris Wipe—————爱丽斯转场 (三角形转场)<br>Linear Wipe————-线性转场<br>Radial Wipe————-半径转场<br>Venetian Blinds———直贡呢的遮掩 (百叶窗式转场)<br>Video (视频)<br>Broadcast Colors—————广播色<br>Reduce Interlace Flicker——-降低频闪<br>Timecode———————–时间码</p><p>AE快捷键介绍：<br>After Effects快捷键<br>项目窗口<br>新项目 Ctrl+Alt+N<br>打开项目 Ctrl+O<br>打开项目时只打开项目窗口 按住Shift键<br>打开上次打开的项目 Ctrl+Alt+Shift+P<br>保存项目 Ctrl+S<br>选择上一子项 上箭头<br>选择下一子项 下箭头<br>打开选择的素材项或合成图像 双击<br>在AE素材窗口中打开影片 Alt+双击<br>激活最近激活的合成图像 \<br>增加选择的子项到最近激活的合成图像中 Ctrl+/<br>显示所选的合成图像的设置 Ctrl+K<br>增加所选的合成图像的渲染队列窗口 Ctrl+Shift+/<br>引入一个素材文件 Ctrl+i<br>引入多个素材文件 Ctrl+Alt+i<br>替换选择层的源素材或合成图像 Alt+从项目窗口拖动素材项到合成图像<br>替换素材文件 Ctrl+H<br>设置解释素材选项 Ctrl+F<br>扫描发生变化的素材 Ctrl+Alt+Shift+L<br>重新调入素材 Ctrl+Alt+L<br>新建文件夹 Ctrl+Alt+Shift+N<br>记录素材解释方法 Ctrl+Alt+C<br>应用素材解释方法 Ctrl+Alt+V<br>设置代理文件 Ctrl+Alt+P<br>退出 Ctrl+Q<br>合成图像、层和素材窗口<br>在打开的窗口中循环 Ctrl+Tab<br>显示/隐藏标题安全区域和动作安全区域 ‘<br>显示/隐藏网格 Ctrl+’<br>显示/隐藏对称网格 Alt+’<br>居中激活的窗口 Ctrl+Alt+\<br>动态修改窗口 Alt+拖动属性控制<br>暂停修改窗口 大写键<br>在当前窗口的标签间循环 Shift+,或Shift+.<br>在当前窗口的标签间循环并自动调整大小 Alt+Shift+,或Alt+Shift+.<br>快照（多至4个） Ctrl+F5,F6,F7,F8<br>显示快照 F5,F6,F7,F8<br>清除快照 Ctrl+Alt+F5,F6,F7,F8<br>显示通道（RGBA) Alt+1，2，3，4<br>带颜色显示通道（RGBA) Alt+Shift+1，2，3，4<br>带颜色显示通道（RGBA) Shift+单击通道图标<br>带颜色显示遮罩通道 Shift+单击ALPHA通道图标<br>显示窗口和面板<br>项目窗口 Ctrl+0<br>项目流程视图 F11<br>渲染队列窗口 Ctrl+Alt+0<br>工具箱 Ctrl+1<br>信息面板 Ctrl+2<br>时间控制面板 Ctrl+3<br>音频面板 Ctrl+4<br>显示/隐藏所有面板 Tab<br>General偏好设置 Ctrl+<br>新合成图像 Ctrl+N<br>关闭激活的标签/窗口 Ctrl+W<br>关闭激活窗口（所有标签） Ctrl+Shift+W<br>关闭激活窗口（除项目窗口） Ctrl+Alt+W<br>时间布局窗口中的移动<br>到工作区开始 Home<br>到工作区结束 Shift+End<br>到前一可见关键帧 J<br>到后一可见关键帧 K<br>到前一可见层时间标记或关键帧 Alt+J<br>到后一可见层时间标记或关键帧 Alt+K<br>到合成图像时间标记 主键盘上的0—9<br>滚动选择的层到时间布局窗口的顶部 X<br>滚动当前时间标记到窗口中心 D<br>到指定时间 Ctrl+G<br>合成图像、时间布局、素材和层窗口中的移动<br>到开始处 Home或Ctrl+Alt+左箭头<br>到结束处 End或Ctrl+Alt+右箭头<br>向前一帧 Page Down或左箭头<br>向前十帧 Shift+Page Down或Ctrl+Shift+左箭头<br>向后一帧 Page Up或右箭头<br>向后十帧 Shift+Page Up或Ctrl+Shift+右箭头<br>到层的入点 i<br>到层的出点 o<br>逼近子项到关键帧、时间标记、入点和出点 Shift+ 拖动子项<br>预示<br>开始/停止播放 空格<br>从当前时间点预视音频 .（数字键盘）<br>RAM预视 0（数字键盘）<br>每隔一帧的RAM预视 Shift+0（数字键盘）<br>保存RAM预视 Ctrl+0（数字键盘）<br>快速视频 Alt+拖动当前时间标记<br>快速音频 Ctrl+拖动当前时间标记<br>线框预视 Alt+0（数字键盘）<br>线框预视时用矩形替代alpha轮廓 Ctrl+Alt+0（数字键盘）<br>线框预视时保留窗口内容 Shift+Alt+0（数字键盘）<br>矩形预视时保留窗口内容 Ctrl+Shift+Alt+0（数字键盘）<br>如未选择层，命令针对所有层<br>合成图像、层和素材窗口中的编辑<br>拷贝 Ctrl+C<br>复制 Ctrl+D<br>剪切 Ctrl+X<br>粘贴 Ctrl+V<br>撤消 Ctrl+Z<br>重做 Ctrl+Shift+Z<br>选择全部 Ctrl+A<br>取消全部选择 Ctrl+Shift+A或F2<br>层、合成图像、文件夹、效果更名 Enter（数字键盘）<br>原应用程序中编辑子项（仅限素材窗口） Ctrl+E<br>合成图像和时间布局窗口中的层操作<br>放在最前面 Ctrl+Shift+ ]<br>向前提一级 Shift+ ]<br>向后放一级 Shift+ [<br>放在最后面 Ctrl+Shift+ [<br>选择下一层 Ctrl+下箭头<br>选择上一层 Ctrl+上箭头<br>通过层号选择层 1—9（数字键盘）<br>取消所有层选择 Ctrl+Shift+A<br>锁定所选层 Ctrl+L<br>释放所有层的选定 Ctrl+Shift+L<br>分裂所选层 Ctrl+Shift+D<br>激活合成图像窗口 \<br>在层窗口中显示选择的层 Enter（数字键盘）<br>显示隐藏视频 Ctrl+Shift+Alt+V<br>隐藏其它视频 Ctrl+Shift+V<br>显示选择层的效果控制窗口 Ctrl+Shift+T或F3<br>在合成图像窗口和时间布局窗口中转换 \<br>打开源层 Alt++双击层<br>在合成图像窗口中不拖动句柄缩放层 Ctrl+拖动层<br>在合成图像窗口中逼近层到框架边和中心 Alt+Shift+拖动层<br>逼近网格转换 Ctrl+Shit+’’<br>逼近参考线转换 Ctrl+Shift+；<br>拉伸层适合合成图像窗口 Ctrl+Alt+F<br>层的反向播放 Ctrl+Alt+R<br>设置入点 [<br>设置入点 ]<br>剪辑层的入点 Alt+[<br>剪辑层的出点 Alt+]<br>所选层的时间重映象转换开关 Ctrl+Alt+T<br>设置质量为最好 Ctrl+U<br>设置质量为草稿 Ctrl+Shift+U<br>设置质量为线框 Ctrl++Shift+U<br>创建新的固态层 Ctrl+Y<br>显示固态层设置 Ctrl+Shift+Y<br>重组层 Ctrl+Shift+C<br>通过时间延伸设置入点 Ctrl+Shift+，<br>通过时间延伸设置出点 Ctrl+Alt+，<br>约束旋转的增量为45度 Shift+拖动旋转工具<br>约束沿X轴或Y 轴移动 Shift+拖动层<br>复位旋转角度为0度 双击旋转工具<br>复位缩放率为100% 双击缩放工具<br>合成图像、层和素材窗口中的空间缩放<br>放大 .<br>缩小 ，<br>缩放至100% 主键盘上的/或双击缩放工具<br>放大并变化窗口 Alt+.或Ctrl+主键盘上的=<br>缩小并变化窗口 Alt+，或Ctrl+主键盘上的-<br>缩放至100%并变化窗口 Alt+主键盘上的/<br>缩放窗口 Ctrl+\<br>缩放窗口适应于监视器 Ctrl+Shift+\<br>窗口居中 Shift+Alt+\<br>缩放窗口适应于窗口 Ctrl+Alt+\<br>图像放大，窗口不变 Ctrl+Alt+ =<br>图像缩小，窗口不变 Ctrl+Alt+ -<br>时间布局窗口中的时间缩放<br>缩放到帧视图 ；<br>放大时间 主键盘上的=<br>缩小时间 主键盘上的-<br>时间布局窗口中查看层属性<br>定位点 A<br>音频级别 L<br>音频波形 LL<br>效果 E<br>遮罩羽化 F<br>遮罩形状 M<br>遮罩不透明度 TT<br>不透明度 T<br>位置 P<br>旋转 R<br>时间重映象 RR<br>缩放 S<br>显示所有动画值 U<br>在对话框中设置层属性值（与P,S,R,F,M一起） Ctrl+Shift+属性快捷键<br>隐藏属性 Alt+Shift+单击属性名<br>弹出属性滑杆 Alt+ 单击属性名<br>增加/删除属性 Shift+单击属性名<br>switches/modes转换 F4<br>为所有选择的层改变设置 Alt+ 单击层开关<br>打开不透明对话框 Ctrl+Shift+O<br>打开定位点对话框 Ctrl+Shift+Alt+A<br>时间布局窗口中工作区的设置<br>设置当前时间标记为工作区开始 B<br>设置当前时间标记为工作区结束 N<br>设置工作区为选择的层 Ctrl+Alt+B<br>未选择层时，设置工作区为合成图像长度 Ctrl+Alt+B<br>时间布局窗口中修改关键帧<br>设置关键帧速度 Ctrl+Shift+K<br>设置关键帧插值法 Ctrl+Alt+K<br>增加或删除关键帧（计时器开启时）或开启时间变化计时器 Alt+Shift+属性快捷键<br>选择一个属性的所有关键帧 单击属性名<br>增加一个效果的所有关键帧到当前关键帧选择 Ctrl+单击效果名<br>逼近关键帧到指定时间 Shift+拖动关键帧<br>向前移动关键帧一帧 Alt+右箭头<br>向后移动关键帧一帧 Alt+左箭头<br>向前移动关键帧十帧 Shift+Alt+右箭头<br>向后移动关键帧十帧 Shift+Alt+左箭头<br>在选择的层中选择所有可见的关键帧 Ctrl+Alt+A<br>到前一可见关键帧 J<br>到后一可见关键帧 K<br>在线性插值法和自动Bezer插值法间转换 Ctrl+单击关键帧<br>改变自动Bezer插值法为连续Bezer插值法 拖动关键帧句柄<br>Hold关键帧转换 Ctrl+Alt+H或Ctrl+Alt+单击关键帧句柄<br>连续Bezer插值法与Bezer插值法间转换 Ctrl+拖动关键帧句柄<br>Easy easy F9<br>Easy easy入点 Alt+F9<br>Easy easy出点 Ctrl+Alt+F9<br>合成图像和时间布局窗口中层的精确操作<br>以指定方向移动层一个像素 箭头<br>旋转层1度 +（数字键盘）<br>旋转层-1度 -（数字键盘）<br>放大层1% Ctrl+ +（数字键盘）<br>缩小层1% Ctrl+ -（数字键盘）<br>移动、旋转和缩放变化量为10 Shift+快捷键<br>层的精调是按当前缩放率下的像素计算，而不是实际像素。<br>合成图像窗口中合成图像的操作<br>显示/隐藏参考线 Ctrl+ ；<br>锁定/释放参考线锁定 Ctrl+Alt+Shift+；<br>显示/隐藏标尺 Ctrl+ R<br>改变背景颜色 Ctrl+Shift+B<br>设置合成图像解析度为full Ctrl+ J<br>设置合成图像解析度为Half Ctrl+ Shift+J<br>设置合成图像解析度为Quarter Ctrl+ Alt+Shift+J<br>设置合成图像解析度为Custom Ctrl+ Alt+J<br>合成图像流程图视图 Alt+F11<br>层窗口中遮罩的操作<br>椭圆遮罩置为整个窗口 双击椭圆工具<br>矩形遮罩置为整个窗口 双击矩形工具<br>在自由变换模式下围绕中心点缩放 Ctrl+ 拖动<br>选择遮罩上的所有点 Alt+单击遮罩<br>自由变换遮罩 双击遮罩<br>推出自由变换遮罩模式 Enter<br>合成图像和实际布局窗口中的遮罩操作<br>定义遮罩形状 Ctrl+ Shift+M<br>定义遮罩羽化 Ctrl+ Shift+F<br>设置遮罩反向 Ctrl+ Shift+I<br>新遮罩 Ctrl+ Shift+N<br>效果控制窗口中的操作<br>选择上一个效果 上箭头<br>选择下一个效果 下箭头<br>扩展/卷收效果控制 `<br>清除层上的所有效果 Ctrl+ Shift+E<br>增加效果控制的关键帧 Alt+单击效果属性名<br>激活包含层的合成图像窗口 \<br>应用上一个喜爱的效果 Ctrl+Alt+Shift+F<br>应用上一个效果 Ctrl+Alt+Shift+E<br>合成图像和实际布局窗口中使用遮罩<br>设置层时间标记 *（数字键盘）<br>清楚层时间标记 Ctrl+单击标记<br>到前一个可见层时间标记或关键帧 Alt+J<br>到下一个可见层时间标记或关键帧 Alt+K<br>到合成图像时间标记 0—9（数字键盘）<br>在当前时间设置并编号一个合成图像时间标记 Shift+0—9（数字键盘）<br>渲染队列窗口<br>制作影片 Ctrl+ M<br>激活最近激活的合成图像 \<br>增加激活的合成图像到渲染队列窗口 Ctrl+ Shift+/<br>在队列中不带输出名复制子项 Ctrl+ D<br>保存帧 Ctrl+Alt+S<br>打开渲染对列窗口 Ctrl+Alt+O<br>工具箱操作<br>选择工具 V<br>旋转工具 W<br>矩形工具 C<br>椭圆工具 Q<br>笔工具 G<br>后移动工具 Y<br>手工具 H<br>缩放工具 （使用Alt缩小） Z<br>从选择工具转换为笔工具 按住Ctrl<br>从笔工具转换为选择工具 按住Ctrl<br>在信息面板显示文件名 Ctrl+Alt+E</p><p>一，Adjust<br>（色彩类）主要都是一些调整参数的滤镜，主要包括以下滤镜：<br>01，Brightness＆Contrast<br>用于调整亮度和对比度<br>02，Channel Mixer<br>Channel Mixer用于通道混合，可以用当前彩色通道的值来修改一个彩色通道。应用Channel Mixer可以产生其它颜色调整工具不易产生的效果；或者通过设置每个通道提供的百分比产生高质量的灰阶图；或者产生高质量的棕色调和其它色调图像；或者交换和复制通道。<br>Red／Green／Blue－Red／Green／BIue／Const分别表不不同的颜色调整通道，Const用来调整通道的对比度。参数以百分比表示，表明增强或减弱该通道的效果。<br>其默认的参数为 Red－Red Green－Green Blue－Blue都是 1O0％，其它为 O％，表示初始的RGB通道值。最下方的Monochrome选项是可以将图像应用为灰阶图<br>03，Color Balance<br>Color Balance用于调整色彩平衡。通过调整层中包含的红、绿、蓝的颜色值，颜色平衡. 效果控制参数<br>Shadow Red／Blue／Green Balance用于调整 RGB彩色的阴影范围平衡。<br>Midtone Red／BIue／Green Balance用于调整 RGB彩色的中问亮度范围平衡。<br>Hilight Red／Blue／Green Balance用于调整 RGB彩色的高光范围平衡。<br>Preserve Luminosity选项用于保持图像的平均亮度，来保持图像的整体平衡。<br>04，Curves<br>Curves用于调整图象的色调曲线，通过改变效果窗口的Curves曲线来改变图象的色调。也可以用Level完成同样的工作，但是Curves的控制能力更强。<br>05，Channel<br>用于选择要进行调控的通道，可以选RGB彩色通道，Red红色通道、Green绿色通道、Bule蓝色通道和Alpha透明通道分别进行调控。 Curves曲线用来调整Gamma。值，即输入（原是亮度）和输出的对比度。<br>06，Hue／Saturation<br>Hue／Saturation用于调整图像中单个颜色分量的Hue色相、Saturation饱和度和<br>Lightness亮度。其应用的效果和Color Balance一样，但利用的是颜色相位调整轮来进行控制。 效果控制参数<br>Channel Control用于选择所应用的颜色通道，选择 Master表示对所有颜色应<br>用，或者Reds红色、 Yellows黄色、 Greens绿色、 Cyans青色和 Blue Magentas<br>洋红。<br>Channnel Range显示颜色映射的谱线，用于控制通道范围。上面的谱线表示调<br>节前的颜色；下面的谱线表示在全饱和度下调整后所对应的颜色。<br>Master Hue用于调整主色调，取值范围-180度～＋ 180度。<br>Master Saturation用于调整主饱和度。<br>Master Lightness用于调整主亮度。<br>Colorize用于调整图像为一个色调值，成为双色图，就像旧电影的棕色。<br>Colorize Hue用于调整双色图色相。<br>Colorize Saturation用于调整双色图饱和度。<br>Colorize Lightness用于调整双色图亮度。<br>07，Levels<br>Levels用于将输入的颜色范围重新映射到输出的颜色范围，还可以改变Gamma<br>正曲线。Levels主要用于基本的影像质量调整，效果控制参数<br>Levels参数中，Channel用于选择要进行调控的通道，可以选择RGB彩色通道、Red红色通道、Green绿色通道、blue蓝色通道和Alpha透明通道分别进行调控。HIStogram该谱线图显示像素值在图像中的分布，水平方向表示亮度值，垂直方向表示该亮度值的像素数量。没有像素值会比输出黑色值更低，比输出白色值更高。<br>InPut Black输入黑色用于限定输入图像黑色值的阀值。<br>InPut White输入白色用于限定输入图像白色值的阀值。<br>Gamma用于设置Gamma值，调整输入输出对比度。<br>OutPut Black输出黑色用于限定输出图像黑色值的阀值。<br>outPut White输出白色，用于限定输出图像白色值的阀值。<br>08，Posterize<br>Posterize用于为每个通道指定一定范围的色调或亮度的级别。如同划分几档<br>Posterize使像素调整到最近的级别上，如图所示。Level 用来设置划分级别的数量，范围从2–32。<br>09，Threshold<br>Threshold用于将灰度图或彩色图象转化为高对比度的黑白二进制图象，Level 用来设置阀值级别，低于这个阀值的像素转化为黑色，高于这个阀值的像素转化为白色<br>二，Audio文件夹内包括音频方面的滤镜，如下：<br>今天把Audio 效果方面的整理出来了！不过我的老师讲AE的音频处理不如PR，建议把音频文件拿到PR中处理。本人这方面实践的比较少，不好说什么，请高手指教、指教！！ Audio 效果，Audio 音频效果用来为音频进行处理.音频效果包括： Backwards\Bass＆Treble\ Delny、Flange＆Chorus、Higl-Low Pass、 Modulator、Parametric EQ、 Reverb、Stereo Mixer、 Tone。其中 Flange＆ Chorus。High－Low Pass、 Modulator、 Parametnc EQ、 Reverb和 Tone都是 After Effects 5．5 Production 中包含的”高级”音频效果<br>1，Backwards<br>Backwards用于将音频素材反向播放，从最后一帧播放到第一帧,在时间线窗口中，这些帧仍然按原来的顺序排列。Swap Channels用于将两个音轨交换<br>2，Bass＆ Treble<br>Bass＆ Treble用于调整高低音调。如果你需要“更强大的音调控制，就要ParametricEQ参数均衡器。Bass 用于升高或降低低音部分。<br>Treble 用于升高或降低高音部分。<br>3，Delay<br>Delay用于延时效果，可以设置声音在一定的时间后重复的效果。用来模拟声音被物体反射的效果。 Delay Time 延时时间，以ms为单位。<br>Dalay Amount 延时量。<br>Feedback 反馈。 Dry out 原音输出，表示不经过修饰的声音输出量. wet out 效果音输出，表示经过修饰的声音输出量<br>4，Flange＆Chorus 这个参数稍多了点：）<br>Flange＆Chorus包括两个独立的音频效果， Chorus用于设置和声效果，<br>使单个语音或者乐器听起来更有深度，可以用来模拟“合唱”效果。Flange<br>用于设置变调效果，通过拷贝失调的声音，或者把某个频率点改变，调节声<br>音分离的时间、音调深度。可以用来产生颤动、急促的声音。应用这个效果<br>的时候，默认的设置为应用Flange效果。<br>Voice Separation Time（ms）用于设置声音分离时间，单位是 ms。每个分离<br>的声音是原音的延时效果声。设置较低的参数值通常用于Flange效果，较高<br>的数值用于Chorus效果。 Voice用于设置和声的数量。ModulationRate用于调整调制速率，以Hz为单位，指定频率调制。Modulation Depth调制深度。Voice Phase Change 声音相位变化。Invertphase讲声音相位相反。Stereo Voices 设置为立体声效果。 Dry on原音输出。wet out效果音输出。如果应用合唱效果，将 Voice Separation Time设置为 40以上，Voice设置为 4，Modulation Rate设置为0.1 Modulation设置为 50％，Voice Phase Change设置为 90，选择Steroe Voice选项，Dry/Wet 都设置为50％。<br>5，high-Low Pass<br>High－Low Pass应用高低通滤波器，只让高于或低于一个频率的声音通过。可以用来模拟增强或减弱一个声音，例如可以用 High Pass滤除外景中的噪音（通常存在于低频），让人声更清晰，LowPass可以消除高频噪声（如静电和峰鸣声）。可以用来改变声音的重点，例如在混合了音乐和人声的声音中突出人声或音乐声。可以独立输出高低音等等。Filter options 用于选择应用High Pass高通滤波器和Low Pass低通滤波器Cutoff Frequency用于切除频率。 Dry out原音输出。 Wet OUt效果音输出。<br>6，Modulator<br>Modulator用于设置声音的颤音效果，改变声音的变化频率和振幅。使用产生声音的多谱勒效果，比如一列火车逼近观察者的时候，啸叫声越来越高，通过时降低。 Modulation TyPe用于选择颤音类型，Sine为正弦值，Triangle为三角形. ModulationDepth用于设置调制深度。AmplitudeModulation用于设置振幅<br>7，Parametric EQ<br>Parametric EQ用于为音频设置参数均衡器。强化或衰减指定的频率。对于增强音乐的效果特别有效。Frequency Response频率响应曲线，水平方向表示频率范围，垂直表示增益值。Bandl／2／3 Enable应用第1／2／3条参数曲线。最多可以使用三条，打开后可以对下面的相应参数进行调整。（这里只使用了一条）Frequency设置调整的频率点。Bandwidth设置带宽。Boost／Cut提升或切除，调整增益值。<br>8，Reverb<br>Reverb通过加入随机反射声模拟现场回声效果。<br>Revefb Time（ms）用于设置回音时间，以 ms为单位<br>Diffusion用于设置扩散量。<br>Decay衰减度，指定效果消失过程的时间。<br>Brightness明亮度<br>Dry out原音输出<br>Wetout效果声输<br>9，Stereo Mixer<br>Stereo Mixer用来模拟左右立体声混音装置。可以对一个层的音频进行音量大小和相位的控制。<br>Left Level左声道增益，即音量大小。<br>Right Level右声道增益。<br>Left Pan左声道相位，即声音左右定位。<br>Right Pan右声道相位。<br>10，Tone<br>Tone效果用来简单合成固定音调。比如潜艇的隆隆声、电话铃声、警笛声以及激光对每一种效果，最多可以增加5个音调产生和弦。我们可以对没有音频的层应用该效对音频层或包含音频的层应用该效果，将只播放合成音调。Waveform options用于选择波形形状。Sine表示正弦波；<br>Square表示方波，产生随失真的声音；Triangle“表示三角波；<br>Saw接近方波音调。Freqencyl／2／3／4／5分别设置五个音调的频率点，如果要关闭某个频率的时候参数设置为0。Level调整振幅。如果预览的时候出现警告声，说明Level设置过高。依照使用的音调个数除100％，如果用满5个音调，则Level值为20％\<br>三，Blur＆ Shmpen使图像模糊和锐化效果<br>Blur＆ Sharpen效果<br>使用 Blur＆ Shmpen效果用来使图像模糊和锐化。其中包括： Channel Blur<br>Compound Blur、 Fast Blur、 Gaussian Blur、 Motion Blur（ Direction Blur方向模糊）Radial Blur、 Sharpen、 Unsharp Mask，模糊效果可能是最常应用的效果，也是一种简便易行的改变画面视觉效果的途径。动态的画面需要“虚实结合”，这样即使是平面合成，也能给人空间感和对比，更能让人产生联想，而且可以使用模糊来提升画面的质量，可能即使是很粗糙的画面，经过处理后也会赏心悦目。所以，应该充分利用各种模糊效果来改善作品质量。<br>1, Channel Blur<br>Channel Blur可以称为“通道模糊”，分别对图像中的红、绿、蓝和 Alpha通道进行模糊，并且可以设置使用水平还是垂直，或者两个方向同时进行，如图，只对蓝色通道进行模糊处理。当该层设置为最高质量（Best Quality）的时候，这种模糊能产生平滑的效果。这种效果的最大好处是可以根据画面颜色分布，进行分别模糊，而不是对整个画面进行模糊，提供了更大的模糊灵活性。可以产生模糊发光的效果，或者对Alpha通道的整幅画面应用，得到不透明的软边<br>Red Blutriness设置红色通道模糊程度。<br>GreenBlutriness设置绿色通道模糊程度。<br>BIueBlurriness设置蓝色通道模糊程度。<br>Alph。Blutriness设置Alph。通道模糊程度。<br>Edge Behavior点击选择<br>RePeat Edge Pixels表示图像外边的像素是透明的；不选择表示图像外边的像素是半透明的。可以防止图像边缘变黑或变为透明。BlurDimensions设置模糊方向，可以选择 Horizontal and Vertical同时向两个方向；<br>Horizontal表示水平方向；Vertical表示垂直方向。<br>2, ComPound Blur<br>Comnound Blur称为“混合模糊”。依据某一层（可以在当前合成中选择）画面的亮度值对该层进行模糊处理，或者为此设置模糊映射层，也就是用一个层的亮度变化去控管另一个层的模糊。图像上的依据层的点亮度越高，模糊越大；亮度越低，模糊越小。 当然，也可以反过来进行设置。<br>Blur Layer用来指定当前合成中的那一层为模糊映射层，当然可以选择本层。<br>Maximum Blur最大模糊，以像素为单位。<br>Stretch Map to Fit如果模糊映射层和本层尺寸不同，伸缩映射层。<br>Invert Blur反向模糊。<br>Compound Blur可以用来模拟大气，如烟雾和火光，特别是映射层为动画时，效果更生动；也可以用来模拟污点和指印，还可以和其它效果，特别是Displacement组合时更为有效。<br>3, Fast Blur<br>Fast Blur称为“快速模糊”，用于设置图像的模糊程度。它和Gaussian BIur<br>十分类似，而它在大面积应用的时候速度更快。<br>Blurrriness用于设置模糊程度。<br>Blur Dimensions设置模糊方向，可以选择Horizontal and Vertical同时向两个方向；<br>Horizontal表示水平方向；Vertical表示垂直方向。<br>4, Gaussian Blur<br>Gaussian Blur称为“高斯模糊”，用于模糊和柔化图像，可以去除杂点，<br>层的质量设置对高斯模糊没有影响。高斯模糊能产生更细腻的模糊效果，<br>尤其是单独使用的时候。<br>Blutrriness用于设置模糊程度。<br>BIur Dimensions设置模糊方向，可以选择 Horizontal and Vertical同时向两个方向；Horizontal表示水平方向；Vertical表示垂直方向。<br>5, directional Blur也可以称之为（motion blur）<br>Motion Blur称为“ 运动 模糊”，也称为Directional Blur方向模糊”。这是一种十分具有动感的模糊效果，可以产生任何方向的运动幻觉。当图层为草稿质量的时候，应用图像边缘的平均值；最高质量的时候，应用高斯模式的模糊，产生平滑、渐变的模糊效果。Direction设置运动模糊方向，以度数为单位。Blur Length用于设置运动模糊的长度。注意：MotionBlur运动模糊效果不同于时间线窗口中的MotionBlur开关，MotionBlur开关是针对某个层的运动画面进行补偿的工具。<br>6, Radial Blur<br>Radial Blur称为“圆周模糊”，在指定的点产生环绕的模糊效果，越靠外模糊越强如图所示。草稿质量时，只显示纹理。这种效果在隔行显示的时候可能会闪烁。Amount模糊程度。Center设置中心位置。Type模糊类型，可以选择Spin旋转，则模糊呈现旋转状；Zoom变焦，模糊呈放射状。Antialiasing(Best Quality）用于设置反锯齿的作用， High表示高质量；Low示低质量，这个选项只有在最高质量是才有效。<br>7, Sharpen<br>Sharpen用于锐化图像，在图像颜色发生变化的地方提高对比度。vSharpen Amount用于设置锐化的程度<br>8, Unsharp Mask<br>Unsharp Mask用于在一个颜色边缘增加对比度。和 Sharpen不同，它不对颜色边缘进行突出，看上去是整体对比度增强。Amount设置效果应用的百分比。 Radius指定两个颜色的边界，受调整的像素的范围。 Threshold指定边界的容限，调整容许的对比度范围 避免调整整个画面的对比度而产生杂点。<br>四, 今天主要是介绍一下Channel效果，<br>相关特效在实际应用中非常有用，跟其他特效配合使用，变化更是精妙，这里的一些效果图只是单一的演示，并不能真正体现这些特效的神髓，其深远的东西有待朋友们再实际的工作中发觉探索！！Channel效果Channel通道效果用来控制、抽取、插入和转换一个图像的通道。通道包含各自的颜色分量（ RGB）、计算颜色值（ HSL）和透明值（ Alpha）。<br>Channel通道效果中包含Alpha Levels、 Arithmetic、 Blend、ComPound Arithmetic、Invert、Minimax、Remove Color Matting、Set Channels、SetMatte、 Shift Channels<br>01, 其中 Alpha Level是高级工具包提供的插件，<br>其主要用来调整通道透明程度.Alpha Levels透明程度设置 AlPha Levels透明程度设置，用于将遮罩中的纯白或纯黑的区域 调整为灰色半透明区域，也可以将灰色半透明区域调整为白色不透明区域或黑色透明区域。应用的时候选择菜单Effect＞ Channel＞ Alpha Levels。Alpha数值通过改变输入限制（ input Limits）、输出限制（ Output Limits）和 Gamma值（控制透明程度）。输入和输出限制用来指示透明的起<br>始和结束，Gamma值用来调整灰度的范围。Gamma值为1，表示灰度为线性值；小于1，灰度值变暗，显得更透明；大于1，灰度值变亮，显得更不透明。在效果窗口可以对 Alpha Levels透明程度进行如下控制InPut Black Level小于或等于此值的 Alpha值为全透明。InPut WhiteLevel大于或等于此值的 Alph。值为不透明。Gamma用于调整灰度曲线。Output Black Level用于设置 Alpha值的输出下限。OutPut White Level用于设置 Alph。值的输出上限。注意：转换半透明为完全透明和不透明时，Oupout Black Level设为 0（最小）， Output White Level设为 255（最大）； 转换完全透明或不透明区域为半透明时，如果 Alpha值，小于 OutPut Black Level，则提升到该值，Alpha值大于 Output White Level，则降低到该值.<br>02, Arithmetic<br>Arithmetic称为“通道运算”，对图像中的红、绿、蓝通道进行简单的运算， operator选择不同的算法。Red Value应用计算中的红色通道数值。GreenValue应用计算中的绿色通道数值。BIue Value应用计算中的蓝色通道数值。Clipping选择Clip Result Values选项用来防止设置的颜色值超出所有功能函数项的限定范围。<br>03, Blend<br>Blend效果称为“通道融合”，可以通过五种方式将两个层融合。和使用层模式类似，但是使用层模式不能设置动画，而Blend通道融合最大的好处是可以设置动画。Blend With Lnyer用于在本合成中选择对本层应用融合的层。Mode选择融合方式，其中包括 Crossfade淡人淡出、Color only颜色融合、Tint色彩融合、 oparken only加深融合和Lighten only加亮融合。Blend With original设置融合程度。 If Layer Sizes Differ如果两个层的尺寸不同，选择Center进行中对齐，Stretchto Fit伸缩自适应。注意：在对一个层应用Blend效果时，可以关闭选择的融合层的可视性。<br>04,compound Arithmetic<br>compound Arithmetic称为“混和运算”，可以将两个层通过运算的方式混合，实际上是和层模式相同的，而且比应用层模式更有效、更方便。这个效果主要是为了兼容以前版本的 After Effects效果。Second Source Layer选择混合的（第二个）图像层。<br>Operator混合算法，其效果和层模式相同。Operate on Channel应用通道，可以选择 RGB、 ARGB和 Alpha通道，Overflow Behavior选择对超出允许范围的像素值的处理方法，可以选择Clip、Warp和Scale。 Stretch Second Source to Fit如果两个层的尺寸不同，进行伸缩自适应。<br>05, Invert<br>lnvert称为“反转效果”，用于转化图像的颜色信息。反转颜色通常有很好的颜色效果Channel选择应用反转效果的通道。Blend Wth original和原图像的混合程度。<br>06, Minimax<br>Minimax称为“最大最小值效果”用于对指定的通道进行最大值或最小值的填充 Maximum是以该范围内最亮的像填充;Minimax是以该范围内最暗的像素填充.而且可以设置方向为水平或垂直，可以选择应用通道十分灵活，效果出众。Operation 用于选择作用方式，可以选择Maximum最大方式、Minimax最小方式、Minimax then Maximum先最小再最大和 Maximum then Minimax先最大再最小，四种方式。Radius设置作用半径，也就是效果的程度。Channel选择应用的通道，我们可以对R、G、B和Alpha通道单独作用，这样可以不影响画面其它元素。Direction选择方向为 Horizontal＆ Vertical水平和垂直、Just Horizontal仅水平方向和fust Vertical仅垂直方向。<br>07, Remove Color Matting<br>Remove Color Matting称为“这罩颜色消除”，用来消除或改变这罩的颜色。这个效果也常常用于使用其它文件的Alpha 通道或填充的时候。如果输人的素材是包含背景的Alpha（Premultiplied Alpha），或者图像中的 Alpha通道是由 After Effects创建的，可能需要去除图像中的光晕，而光晕通常是和背景及图像有很大反差的。我们可以通过Remove Color Matting来消除或改变光晕。<br>08,Set Channels<br>Set Channel称为“通道设置”，用于复制其它层的通道到当前颜色通道和 Alpha通道中。比如，选择某一层的亮度值应用到当前层的颜色通道中，该效果等于重新指定当前层的Alpha通道。Source Layerl／2／3／4可以分别将本层的RGBA四个通道改为其它层。 Set Red／Green／Blue／Alpha To Source l／2／3／4’s用于选择本层要被替换的 RGBA通道。 if Layer Sizes Differ当两层图像尺寸不同的时候，选择Stretch Layers to Fit伸缩自适应，来使两层变为同样大小。<br>09, Set Matte<br>Set Matte称为“遮罩设置”，用于将其它图层的通道设置为本层的遮罩，通常用来创建运动遮罩效果。应用时如同使用时间线窗口中的TrkMat轨道遮罩，设置、上面的层设置、上面的层为遮罩层。而 Set Matte效果主要是用来和以前版本的AfterEffects兼容.Take Matte From Layer选择要应用这罩的层。Use For Matte选择哪一个通道作为本层的遮罩。Invert Matte遮罩反向。 If Layer Sizes Differ如果两层尺寸不同，选择 Stretch Matte to Fit伸缩遮罩层自适应， Composite Matte with Original将这罩和原图像合成， Premultiply Matte Layer选择和背景合成的遮罩层。<br>10, Shift Channels<br>Channels称为“通道转换”，用于在本层的RGBA通道之间转换主要对图象的色彩和亮暗产生效果，也可以消除某种颜色，Take Alpha／Red／Green／Blue分别从旁边的弹出菜单中选择本层的其它通道应用到Alpha、Red、Green和Blue通道。<br>11, Cineon tools效果概述<br>在这个子菜单中，只包含 Cineon Coverter一个效果，其实它更主要是设置10位的Cineon文件，让它如实还原本色，以适应 8位的 After EffectS处理。由于胶片扫描而来的 Cineon 10位文件，有着更宽的动态范围，所以这个工具基本用来设置10位和8位之间的白、黑点对应以及Gamma还原曲线值。<br>注意：Cineon Coverter只是一个转换器，而不是特技效果，所以我们最好不要用它来处理其它8bit图像。Conversion Type选择转换类型。<br>10／8 Bit Black Point分别设置对应的黑点参数。<br>10／8Bit White Point分别设置对应的白点参数。<br>Gamma调整Gamma还原曲线。<br>Highligh Rolloff高光滤除，通常 10bit的图像动态范围更大体现在失真的高光区域，调整这个值可以很有效地还原图像。<br>五, Video效果<br>Video视频效果中，包含广播级颜色、场控补偿和时间码几个效果，其菜单如下.<br>1, Broadcast Color<br>roadcast Color用于校正广播级的颜色和亮度。由于电视信号发射带宽的限制，如我国用的PAL制发射信号为8MHz带宽。美国和日本使用的NTSC发射信号为 6MHz，由于其中还包括音频的调制信号，进一步限制了带宽的应用。所以并非我们在电脑上看到的所有颜色和亮度都可以反映在最终的电视信号上，而且一旦亮度和颜色超标，会干扰到电视信号中的音频而出现杂音。那究竟什么样的信号不会超过电视台的播出技术标准呢？如我们通常见到的彩条信号，它的亮度和颜色饱和度大约是可见光范围的75％，所以也称为75％彩条，制作中应用的颜色和亮度应低于这个值。在电视台的合成机房中，包含有两个信号监测的是波器，一个叫波形示波器，监视亮度信号的幅度；一个叫矢量示波器，监视颜色信号的饱和度。<br>Broadcast Locale选择应用的电视制式， PAL或 NTSC。<br>How to Make Color Safe实现“安全色”的方法，包括 Reduce Luminance降低亮度、 Reduce Saturation降低饱和度、 Key out Unsafe将不<br>安全的像素透明和Key out Safe将安全颜色透明。后两项主要用来了解安全色的区域。<br>Maximum Signal Amplitude(IRE)限制最大的信号幅度，最大为120可能已经超标，用默认的110比较保守。 2, Reduce Interlance Flicker<br>Reduce Interlance Flicker用于消除隔行闪烁现象。对于图像中的高色度部分，隔行扫描的时候可能会出现闪烁，应用本效果可以将过高的色度降低。此外也可以消除水平线调和残影，但对于一般图像并不明显。 softness柔化图像的边界，避免细线条隔行扫描的时候产生闪烁。<br>3, Timecode<br>Timecode是时间码，影视后期制作的时间依据，由于我们渲染的影片还要拿去配音或者加入三维动画等等，每一帧包含时间码会有利于其它制作方面的配合，Mode选择时间码显示模式。Display Format设置时间码格式，电视用 SMPTE HH：MM：SS：FF，电影用Frame Number胶片编号。<br>Time Units时间单位，应该跟合成设置对应，比如 PAL制的 25帧／秒。<br>Starting Frame设置初始数值。<br>Text Position时间码显示位置。<br>Text Size时间码字号。<br>Text Color时间码颜色。<br>六, 今天主要是把Perspective特效方面的整理出来了！！<br>Perspective用于制作各种透视效果，在简单的三维环境中放置图像，可以增加深度和调节Z轴。这部分效果是从 After Effects 4．0以后加入的，由此可见After Effects正向三维合成努力。但它不像 Discreet Logic Effect*那样从根本上集成了三维合成，而且包括灯光、摄像机以及画面产生各种光感的效果。Perspective只提供了基本的三维环境中的几何变换，使我们可以做出有“深度”的图像。<br>1, Basic 3D<br>Basic 3D基本三维效果，用来使画面在三维空间中水平或垂直移动，也可以拉远或靠近，此外还可以建立一个增强亮度的镜子以反射旋转表面的光芒。因为默认的光源来自图像上方，所以如果想看到图像反射光线，只有让图像向后倾斜。Swivel控制水平方向旋转。<br>Tilt控制垂直方向旋转。 Distance to Image图像纵深距离。Specular Highlight用于添加一束光线反射旋转层表面。Preview选择 Draw Preview Wireframe用于在预览的时候只显示线框。这主要是因为三维空间对系统的资源占用量相当大，这样可以节约资源，提高响应速度。<br>这种方式仅在草稿质量时有效，最好质量的时候这个设置无效。<br>2, Bevel Alpha<br>Bevel Alpha是“ Alpha斜切”，可以使图像出现分界，是通过二维的Alpha<br>通道效果形成三维外观。此效果特别适合包含文本的图像.Edge Thickness边缘厚度。<br>Light Angle 灯光角度。Light Color灯光颜色。Light Intensity灯光强度。<br>3, Bevel Edge<br>Bevel Edge称为“边缘斜切”用于对图像的边缘产生一个立体的效果，看上去是三维的外观。此外，只能对矩形的图像形状应用，不能应用在带有Alpha通道的图像上。<br>Edge Thickness边缘厚度。<br>Light Angle灯光角度。<br>Light Color灯光颜色。<br>Light Intensity灯光强度。。<br>4, Drop Shadow<br>Dron Shadow用于产生“投影效果”，是在层的后面产生阴影。产生阴影的形状由 Alphs通道决定。<br>Shadow Color阴影颜色。<br>Direction阴影方向。<br>Distance阴影距离。<br>softness柔化效果。<br>5, 再补充一个Transform ,其实这个特效在变形文件夹里面.<br>Transform称为“变换效果”，用于在图像中产生二维的几何变换，从而增加了层的变换属性。Anchor Point定位点设置。Position位置设置。 Scale Height／ Width高度／宽度缩放。 Skew倾斜大小。 Skew Axis倾斜轴线。 Rotation旋转方向。 opacity不透明度。 Shutter Angle快门角度设置，由此决定运动模糊的程度。<br>七,Image Control效果<br>Image Control图像控制效果主要用来对图像的颜色进行调整。其中包括 ChangeColor、 Color Balance、 Equalize、 Gamma/pedestal/Gain、 Median、 PS ArBitrary MaP和Tint。 我们可以选择菜单 Effect＞ Image Control下面的选项来应用效果。<br>1,Change Color<br>Change Color称为颜色替换，用于改变图像中的某种颜色区域（创建某种颜色遮罩）的色调饱和度和亮度。可以通过制定某一个基色和设置相似值来确定区域，View选择合成窗口的观察效果。可以选择Color Correction Layer颜色校正视图或 Color Correction Mask颜色校正遮罩。<br>Hue Transform色相调制，以度为单位改变所选颜色区域。<br>Lightness Transform亮度调制。<br>Stauration Transform饱和度调制。<br>Color To Change选择图像中要改变颜色的区域颜色。<br>Matching Tolerance调整颜色匹配的相似程度。<br>Matching Softness匹配柔和度。<br>Match color选择匹配的颜色空间。可以使用 RGB、 Hue色相和 Chroma浓度。<br>Invert Color Correction Mask颜色校正遮罩反向<br>2，Color Balance（HLS）<br>Color Balance称为“颜色平衡”，用来调整图像色调。这个效果主要是为了和以前的After Effects兼容，所以在这里就不详细讲述了，在After Effects 5．5中，使用Hue／Saturaion更为有效<br>3，Equalize<br>Equalize颜色均衡效果，用来使图像变化平均化，Equalize选择均衡方式。可以选择RGB、Brightness亮度值和Photoshop Style表示应用Photoshop风格的调整。 Amount to Equalize设置重新分布亮度值的百分比。<br>4，Gamma/Pedestal/Gain<br>Gamma/Pedestal/Gain用来调整每个RGB独立通道的还原曲线值，这样可以分别对某种颜色进行输出曲线控制。对于Pedestal和Gain，设置0为完全关闭，设置1为完全打开Gamma/Pedestal/Gain控制参数如下：<br>Black Stretch用来重新设置黑色（最暗）强度。<br>Red／Green／Blue Gamma分别调整红色／绿色／蓝色通道的 Gamma曲线值<br>Red／Green／Blue Pedestal分别调整红色／绿色／蓝色通道的最低输出值。<br>Red／Green／Blue Gain分别调整红色／绿色／蓝色通道的最大输出值。<br>5，Median<br>Median称为“中值效果”，使用给定半径范围内的像素的平均值来取代像素值。取较低数值的时候，该效果用来减少画面中的杂点；取高值的时候产生一种绘画效果，<br>Radius指定像素半径。operate on Alpha Channel应用于 Alpha通道。<br>6，PS Arbitrary Map<br>PS Arbitrary Map用于调整图像的色调的亮度级别。如同在 Photoshop文件中我们可以设置一个层的Arbitrary Map文件然后应用到整个层，Phase颜色相位。Apply Phase Map To Alpha应用相位图到Alpha通道。<br>7，Tint<br>Tint用来调整图像中包含的颜色信息，在最亮和最暗的之间确定融合度；所示。黑色像素被映射到Map Black To项指定的颜色；白色像素被映射至Map White TO项指定的颜色，介于两者之间的颜色被赋予对应的中间值。Map Black to映射黑色到某种颜色。Map White to映射白色到某种颜色。Amount to Tint应用程度。<br>8，Colorama<br>这个特效比较特别，可以用来实现彩光、彩虹、霓虹灯等等多种神奇效果。<br>具体的应用只有多多实践才能体会！<br>八，这次主要是Distort效果<br>此类特效在AE中应用很广泛，教程中不可能把其千变万化的效果完全体现出来，这里只是讲个大概，个中滋味，自己体验吧！！(图片上有的特效，教程中没有提到的，是第三方插件）， Distort效果主要用来对图像进行扭曲变形，是很重要的一类画面特技。在AfterEffects5.5 Production Bandle中提供了十分丰富的变形效果。其中只有 Mirror、 offset、Polar Coordinates、 Smear、 Spherize为标准版中所带的，其它的都是高级工具包中的<br>Bezier Warp称为“曲线变形”，可以多点控制。在层的边界上沿一个封闭曲线来变形图像。曲线分为四段，每段由四个控制点组成，其中包</p><p>括两个定点和两个切点，顶点控制线段位置，切点控制线段曲率。<br>我们可以利用Bezler Warp产生标签贴在瓶子上的效果，或者用来模拟镜头，如鱼眼和广角。或者可以校正图像的扭曲。通过设置关键帧，还</p><p>可以产生液体流动和简单的旗飘效果等等！！<br>Top Left／Right Vertex用于定位上面的左右两个顶点。<br>Top Left/Right Tangent用于定位上面的左右两个切点。<br>Right Top／Bottiom Vertex用于定位右面的上下两个顶点。<br>Right Top／Bottiom Tangent用于定位右面的上下两个切点。<br>Bottom Left／Right Vertex用于定位下面的左右两个顶点。<br>Bottom Left/ Tangent用于定位下面的左右两个切点。<br>Left Top/Bottom Vertex用于定位左面的上下两个顶点。<br>Left Top／Bottom Tanget用于定位左面的上下两个切点。<br>Elasticity用来设置弹性方式，可以选择Stiff如同冷橡胶，图像变形较小；<br>Normal普通；Loose松动，接近液体效果；Liquid如同热橡胶，允许图像像液体一样变形。 特别注意：应该避免产生褶皱现象（因为会出现锯</p><p>齿变形）；也应该避免产生钝角（因为图像不能紧密的跟随变化）。可以通过弹性选择，改善褶皱和变形产生的不如意的结果。<br>2， Bulge<br>Bulge称为“凸凹效果”或“放大镜效果”，模拟图像透过气泡或放大镜的效果<br>Horizontal Radius水平半径。<br>Vertical Radius垂直半径。<br>Bulge Center定位点。<br>Bulge Height凸凹程度设置，正值为凸，负值为凹。<br>TaPer Radius锥形半径，用来设置凸凹边界的锐利程度。<br>Antialiasing反锯齿设置，只用于最高质量。<br>Pinning选择 Pin All Edges为定住所有边界。<br>3， Corner Pin<br>Corner Pin称为“边角定位”，通过改变四个角的位置来变形图像，主要是用来根据需要定位，可以拉伸、收缩、倾斜和扭曲图形，也可以用</p><p>来模拟透视效果，可以和运动遮罩层相结合，形成画中画效果。 Upper Left左上定位点 。Upper Right右上定位点。<br>Lower Left左下定位点。Lower right右下定位点。 控制很简单。<br>4，DisplacementMap<br>Diaplacement Map称为“映射置换”或“层位移贴图”可以使用任何层作为映射层，通过映射的像素颜色值来对本层变形。实际是应用映射层</p><p>的某个通道值对图像进行水平或垂直方向的变形。<br>Displacement Map Layer选择本合成中的图像层为映射。<br>Use ForHorizontal/Vertical Displacement 选择映射层对本层水平或垂直方向起作<br>用的通道。<br>Max Horizontal/Vertical Displacement最大水平或垂直变形程度。<br>Displacement Map Behavlor置换方式， Center Map映射居中，<br>Stretch Map toFit伸缩自适应。<br>Tile Map置换平铺。<br>Edge Behavior边缘设置，可以选择Warp Pixels Around变形像素包围。选择映射层，<br>5，Mesh Warp<br>Mesh Warp称为“面片变形”，应用网格化的曲线切片控制图像的变形区域，对于画片变形的效果控制，更多的是在合成图像中通过鼠标拖曳</p><p>网格的节点完成。可以将静态图片做成“开口笑”等等，很有意思。Rows用于设置行数。Columns用于设置列数。 Elesticity弹性设置. Gird </p><p>Value网格值显示，用于改变分辨率使行列数发生变化时显示. 拖拽节点如果要调整更细微的效果，可以增加行/列数（控制节点）：<br>6，Mirror<br>Mirror称为“镜面效果”，通过可以设定角度的直线将画面反射，产生对称效果。<br>Reflection Center设置反射中心，也就是反射参考线的位置<br>Reflection Angle用于设置反射角度，也就是反射参考线的斜率。<br>7，offset<br>offset称为“偏移效果”，用于在图像内，图像从一边偏向另一边。<br>Shift Center To用于设置原图像的偏移中心 ，<br>Blend With original和原图像混合程度。<br>8，OPTICS COMPANSATION<br>用来模拟摄象机透视效果，参数比较简单，可以自己调调看。<br>9，Polar Coodlnates<br>Polar Coordinates称为“极坐标”，用来将图像的直角坐标转化为极坐标，以产生扭曲效果。 Interpolation设置扭曲程度。 Type of </p><p>Conversion设置转换类型， 其中选择 Polar to Rect表示将极坐标转化为直角坐标； Rect to polar表示将直角坐标转化为极坐标。<br>10， RESHAPE<br>称为“再成型效果”，需要借助几个遮罩才能实现，通过同一层中的三个遮罩，重新限定图象形状，并产生变形效果。使用方法：<br>1-在素材加上此特效。 2-在素材的起始状态建一个遮罩。 3-在素材的结束位置建一个遮罩。 4-再建一个能框住前两个遮罩的大区域遮罩。 </p><p>5-把Source Mask选Mask 1，Destination Mask选Mask 2， Boundary Mask选Mask 3。 6-Percent调成100。<br>调整参数：<br>Source Mask设置源遮罩。<br>Destination Mask设置目标遮罩。<br>Boundary Mask设置边界遮罩。<br>Percent设置变化百分比。<br>Elashcity弹性设置。<br>Correspondance Points指定源遮罩和目标遮罩对应点的数量。<br>Interpolation Method插值方式。 Discrete表示离散的， Linear表示线性的<br>Smooth表示平滑的。<br>注意：在设置遮罩的时候使用不同的这罩名称，对本效果十分有利。<br>11，RIPPLE<br>称为”波纹效果”或“涟漪效果”，就像水池表面的波纹。<br>12，Smear<br>Smear称为“涂抹效果”，通过使用遮罩在图像中定义一个区域，然后用作用遮罩<br>移动位置来进行“涂抹”变形。 使用方法：1-先在素材上画两个遮罩。2-调整Precent的值。<br>Source Mask设置源遮罩。<br>Boundary Mask设置边界遮罩。<br>Mask Offset遮罩位移。<br>Missk Rotation遮罩旋转。<br>Mask Scale遮罩大小。<br>Precent变化程度百分比。<br>Elasticity弹性设置。<br>Interpolation Method插值方法,Discrete 表示离散的，Linear 表示线线性的<br>Smooth表示平滑的。<br>13, Spherize<br>Spherize“球面化效果”，如同图像包围到不同半径的球面上。<br>控制参数如图：<br>Radius设置球面半径。<br>Center of Sphere设置球心。<br>14，transform<br>可以称为“变换效果”。比较简单，自己尝试。<br>15，twirl<br>可以称为“旋涡效果”。太常见了，PS里就有，不多解释了。<br>16，Wave Warp<br>Wave Warp称为“波浪变形”，可以设置自动的飘动或波浪效果。<br>控制参数如图：<br>wave Type选择波形类型，包括正弦、方波、三角波和噪波等。<br>Wave Hight设置波形高度。<br>Wave Width设置波形宽度。<br>Direction设置波动方向。<br>Wave Speed设置波动速度，可以按该速度自动波动。<br>Pinning设置边角定位，用于显示或不显示图像边缘的各种波浪效果。可以分别控制某个边缘，从而带来很大的灵活性。<br>Phase设置相位。<br>Antialiasing选择反锯齿程度。<br>注意：使用Wave Warp的最大好处是可以让波形“自动”移动，而不需要用关键帧来设置运动效果。可以轻易地制作出动态的旗飘和波浪效果</p><p>，并且可以通过对波动速度设置关键帧，改变固有的变化频率，产生生动的效果。<br>magnify—放大镜效果？？？？<br>九，Simuation中的 Partcle Playground。<br>Simuation中的 Partcle Playground应用综述：Particle Playground是“粒子场”，也就是 After Effects中的粒子效果。粒子在后期制作</p><p>中的应用十分广泛，是高级后期制作软件的标志。可以用粒子系统来模拟雨雪、火和矩阵文字等。<br>Cannon控制项，用于设置粒子发射器<br>Position用于定位粒于发射器。<br>Particles Per Second每秒产生粒子数目。<br>Direction粒子方向。<br>Direction Random Spread方向随机性。<br>Velocity 初始速度。<br>Velocity Random Spread速度随机性。<br>Color粒子颜色。<br>Particle Radius粒子半径。<br>Gird控制项，在每个网格的节点处产生新粒子，用于产生一个均匀的粒子面，产生的粒子不存在速度问题，完全由重力、斥力墙和属性映射来</p><p>控制。默认的设置，由于重力打开，所以都向下运动。<br>Position用于确定网格中心的位置。<br>Width网格宽度。<br>Height网格高度。<br>Particles Across确定水平方向上产生的粒子数 ，默认的情况为0，所以看不到粒子。<br>Particies Down确定垂直方向上产生的粒子数。<br>Color粒子颜色。<br>Particie Radius粒子半径。<br>注意：默认的情况下，使用Cannon产生粒子，如果要使用Gird，则需要将 Cannon中的Particle Per Second设为0，同时设置适当的Particles </p><p>Across／Down的数值。<br>Layer Exploder控制项，用于设置层爆破，从而分裂一个层作为粒子。<br>我们经常可以看到把一个画面粉碎成小块，同时可以模拟烟火和增加粒子数量。<br>Layer Explode对层应用<br>Explode Layer设置应用粒子的层。<br>Radius of New Particles新产生粒子半径。<br>Velocity Dispersion速度分布。‘<br>Particle Exploder选择项，用于对粒子场应用爆破效果<br>Radius of New Particles新产生粒子半径。<br>Velocity Dispersion速度分布。<br>Affects对粒子场影响。必须应用本属性才能应用于一个粒子集。<br>Layer Map控制项，用新的物件代替由 Cannon、 Gird和Layer／Particle Exploder产生的粒子。<br>Use Layer用于指定作为映射的层。<br>Time offset Type时间位移类型。<br>Affects影响属性。<br>Gravity控制项，用于设置重力场。<br>Force重力大小。<br>Force Random Spread重力随机性。<br>Direction重力方向。<br>Affects影响属性。<br>Repel选择项，设置斥力。<br>Force斥力大小。<br>Force Radius斥力半径。<br>Repller斥力控制器。<br>Affects影响属性。<br>Wall选择项，设置墙属性。<br>Boundary选择封闭遮罩作为边界。“<br>Affects影响属性。<br>Persistent Property Mapper选择项，用于指定持久的属性映射器<br>Use Layer As Map选择一个层修改粒子属性。<br>Affects影响属性。<br>Map Red／Green／Blue to映射粒子的 RGB通道的算法。<br>Min／Max指定最小／最大变化范围。<br>Ephemeral Property Mapper选择项，用于指定暂时属性映射器，<br>其中的子属性和上面持久的属性映射器相同。<br>总之，我们可以用After Effects的粒子场来产生很多的纷乱复杂的事物，通过替换<br>粒子映射，也就是说粒子是由其它物件构成，产生不同的效果，<br>十，今天整理出风格化（StyliZe）效果<br>这组特效，详情如下：特效在实际应用中变化无穷，这里的例图只是表现了某一方面的效果，并不能完全体现其精髓，这只能靠自己在实践中</p><p>体验了：）StyliZe是一组风格化效果，用来模拟一些实际的绘画效果或为画面提供某种风格化效果。风格化效果菜单包含如笔触/描边浮雕/</p><p>发光/噪波等效果！Brush Strokes ，Color Emboss ，Emboss ，Find Edges ，Glow，Leave Color，Mosaic，Motion Tile，Noise，Roughen </p><p>Edges ，Scatter，Strobe Light，Texturize，Write-on<br>1, Bruse Strokes<br>Brush htrokes称为“笔触效果”，对图像产生类似水彩画效果。<br>Stroke Angle 笔触角度<br>Brush Size笔触大小<br>Stroke Length笔触长度<br>Stroke Density笔触密度。<br>Stroke Randomness笔触随机性。<br>Paint Surface绘画表面。<br>Blend With Original和原图像混合<br>2, Color Emboss<br>Color Emboss称为“彩色浮雕”，效果和Emboss浮雕效果类似，不同的是本效果包含颜色，如图所示：Direction浮雕方向。 Relief浮雕大小</p><p>。 Contrast对比度。 Blend With original和原图像混合<br>3, Find Edge<br>Find Edge称为“勾边效果”，通过强化过渡像素产生彩色线条。Invert用于反向勾边结果。Blend With original和原图像混合。<br>4, Glow<br>Glow称为“发光效果”，经常用于图像中的文字和带有Alpha通道的图像，产生发光效果。<br>Glow Base on选择发光作用通道。可以选择 Color Channel和 Alpha Channel<br>Glow Threshold发光程度。<br>Glow Radius发光半径。<br>Glow Intensity发光密度。<br>Composite original和原画面合成。<br>Glow operation发光模式，类似层模式的选择。<br>Glow Colors发光颜色。<br>Color Looping颜色循环<br>Color Loops颜色循环方式。<br>Color Phase颜色相位，<br>ColorA＆B Midpoint颜色A和B的中点百分比。<br>ColorA选择颜色A。<br>ColorB选择颜色B。<br>Glow Dimensions发光作用方向（水平／垂直／水平十垂直）<br>5, Leave Color<br>Leave Color用于消除给定颜色，或者删除层中的其它颜色<br>Amount to Decolor设置脱色程度。<br>Color TO Leave选择脱色。<br>Tolerance相似程度。<br>Edge Softness边缘柔化。<br>Match colors颜色对应。可以使用 RGB和 Hue。<br>6, Mosaic<br>Mosaic效果称为“马赛克效果”，使画面产生马赛克.<br>效控参数：Horizontal Blocks水平色块大小。<br>Vertical Blocks垂直色块大小。<br>7, Motion Tile<br>Motion Tile称为“运动分布”，同屏画面中显示多个相同的画面。<br>Tile Center分布定位。<br>Tile Width分布宽度。<br>Tile Hight分布高度。<br>output Width输出宽度。<br>output Hight输出高度。<br>Phase分布相位。<br>Horizontal Phase Shift应用水平位移。<br>8, Noise<br>Noise用于产生画面噪波，主要是通过在画面中加入细小的杂点。Amountof Noise设置噪波数量，调整噪波密度。Noise Type噪波类型。选择</p><p>Color Noise使噪波应用彩色像素。 Clipping使原像素和彩色像素交互出现。<br>9, Roughen Edges<br>Roughen Edges边缘粗糙化，可以模拟腐蚀的纹理或融解效果。<br>Edge Type 边缘类型<br>Edge Color边缘颜色<br>Border边沿<br>Edge Sharpness轮廓清晰度<br>Fractal Influence 不规则影响程度<br>Scale 缩放<br>Stretch Width or Height 控制宽度和高度的延伸程度<br>Offset (Turbulence) 偏移设置<br>Complexity 复杂度<br>Evolution 控制边缘的粗糙变化<br>Evolution Options<br>Cycle (in Revolutions) 循环旋转<br>Random Seed 随机速度<br>10, Scatter<br>Scatter称为“分散效果”，像素被随机分散，产生一种透过毛玻璃观察物体的效果，scatter Amount像素分散数量。<br>Grain设置分散方向。<br>Scatter Randomness设置随机性。选择 Randomize Every Frame使每帧画面重新运算。<br>11, Strobe Light<br>Strobe Light称为“闪光灯效果”，它是一个随时间变化的效果，在一些画面中间不断地加入一帧闪白、其它颜色或应用一帧层模式，然后立</p><p>刻恢复，使连续画面产生闪烁的效果，可以用来模拟电脑屏幕的闪烁或配合音乐增强感染力，Strobe Color选择闪烁色。<br>Blend With Original和原图像混合程度。<br>Strobe Duration（secs）闪烁周期，以秒维单位。<br>Strobe Period（secs）间隔时间，以秒为单位。<br>Random Strobe Probablity闪烁随机性。<br>Strobe闪烁方式，可以选择 operates On Color Only在彩色图像上进行或<br>Mask Layer Transparent在遮罩上进行。<br>Strobe Operator选择闪烁的叠加模式。<br>12, Texturize<br>Texturize称为“贴图化效果”，应用其它层对本层产生浮雕形式的贴图效果。控制参数如下：Texture Layer选择合成中的贴图层。 Light </p><p>Direction灯光方向。 Texture Contrast贴图对比度。 Texture Placement贴图放置，可以平铺、居中或拉伸。<br>13, Emboss<br>Emboss称为“浮雕效果”，不同于 Color Emboss的地方在于本效果不对中间的彩色像素应用，只对边缘应用。Direction浮雕方向。 Relief</p><p>凸起高度。 Contrast边缘对比度。 Blend With Original和原图像混合。<br>14, Write－on<br>Write－on效果是用画笔在一层中绘画，模拟笔迹和绘制过程。 其应用相对有些复杂，<br>十一，Text特效<br>Text效果用来产生重叠的文字、数字（编辑时间码）、屏幕滚动和标题等等。在AE5.5中有3项<br>1， Basic Text<br>Basic Text用于生成基本文字<br>Font/Style:字体/风格<br>Direction（Horizontal/Vertical/Rotate）: 书写方向（水平/垂直/旋转）<br>Alignment:对齐方式<br>Top 顶部<br>Center居中<br>Bottom底部<br>Show Font输入时显示字体<br>Position 书写位置<br>Display Options 文字外观设置，可选择只显示面、边，面在边上或边在面上。<br>Fill Color面颜色<br>Stroke Color边颜色<br>Stroke Width 设置边的宽度<br>Size 字的大小<br>Tracking 字间距<br>Line Spacing 字行宽<br>Composite On Original与原图像合成，否则背景为黑色。<br>2，Numbers称为“数字效果”。<br>产生相关 的数字，可以编辑时间码、十六进制数字、当前日期<br>等，并且可以随时间变动刷新，或者随机乱序刷新。<br>参数基本同Basic Text的相似，解释几个不同的，其余不说了。<br>Type设置数字类型，可以选数字、时间码、日期、时间和十六进制数字<br>Random Values选择数字随机变化<br>Decimal Places小数点位置<br>Value/Offset/Random Max设置数字随机离散范围<br>3，Path Text 路径文字特效，另外，文字运动路径还可以通过自定义MASK实现<br>十二，“抠像”即“键控技术”在影视制作领域是被广泛采用的技术手段<br>实现方法也普遍被人们知道一些――当您看到演员在绿色或蓝色构成的背景前表演，但这些背景在最终的影片中是见不到的，就是运用了键控</p><p>技术，用其它背景画面替换了蓝色或绿色，这就是 “抠像”。当然，“抠像”并不是只能用蓝或绿，只要是单一的、比较纯的颜色就可以，</p><p>但是与演员的服装、皮肤的颜色反差越大越好，这样键控比较容易实现。如果是实时的“抠像”都需要视频切换台或者支持实时色键的视频捕</p><p>获卡。但价格比较昂贵，个人基本上是承受不了的。在After Effects中，实现键控的工具都在特技效果中，标准版的After Effects 5.5内置</p><p>的特效只包括Color Key色键和Luma Key亮键：完整版After Effects 5.5 Production Bandle包含了 Color Difference Key颜色差值键、 </p><p>LinerColor Key线性色键， Difference Matte差值遮罩、 Color Range颜色范围键控、 Extract抽取键控。</p><p>1， 应用Color Key<br>对于单一的背景颜色，可称为键控色。当选择了一个键控色（即吸管吸取的颜色〕，应用Color Key，被选颜色部分变为透明。同时可以控制</p><p>键控色的相似程度．调整透明的效果。还可以对健控的边缘进行羽化，消除“毛边”的区域。效控参数如图：<br>具体使用Color Key色键的方法：举个小例子，使用一张白色背景的蝴蝶图片和一张黑背景的花朵图片，抠去蝴蝶图片的白色背景，使其看上</p><p>去好像落在花上。首先选择要应用色键的层。――－在例子中我选择白色背景的蝴蝶图片。再给其加上Color Key特效（菜单</p><p>Effect&gt;Keying&gt;Color Key）， 应用Color Key色键。 其次，效果控制窗口中，单击小吸管，鼠标箭头变成吸管状，然后在蝴蝶图片的白色区</p><p>域单击一下，（或者点击颜色方块，弹出“颜色”对话框，用HSL或RGB方式指定一个颜色）。击“吸管”按钮，在层窗口或合成窗口中选择颜</p><p>色，如图–单击后,我们看到白色区域消失了，但蝴蝶边缘还有白色的锯齿毛边。这时需要调整以下参数： Color Tolerance用于控制颜色容</p><p>差范围。值越小，颜色范围越小。 Edge Thin用于调整键控边缘，正值扩大遮罩范围，负值缩小遮罩范围。 Edge Fether用于羽化键控边缘，</p><p>产生细腻、稳定的键控遮罩。<br>2，使用Color Range颜色范围键控<br>Color Range颜色范围键控通过键出指定的颜色范围产生透明，可以应用的色彩空间包括Lab、YUV和RGB。这种键控方式，可以应用在背景包含</p><p>多个颜色、背景亮度不均匀和包含相同颜色的阴影(如玻璃、烟雾等)，<br>遮罩视图 用于显示遮罩情况的略图。<br>键控滴管 用于在遮罩视图选择开始的键控色。<br>加滴管 增加键控色的颜色范围。<br>减滴管 减少键控色的颜色范围。<br>Fuziness 用于调整边缘柔化度、<br>Color Space选择颜色空间，有 Lab、YUV和RGB可供选择。<br>Min／Max精确凋整颜色空间参数L，Y，R、a,U,G和b，V，B代表颜色空间的三个分量。Min<strong>调整颜色范围开始，Max</strong>调整颜色范围结束。<br>3，使用Difference Matte差值遮罩<br>Difference Matte差值遮罩通过比较两层画面，键出相应的位置和颜色相同的像素。 最典型的应用是静态背景、固定摄像机、固定镜头和曝</p><p>光，只需要一帧背景素材，然后让对象在场景中移动，效果控制参数如图：<br>View可以切换预览窗口和合成窗口的视图，选择Final Output最终输出结果、Source Only显示源素材和Matte Only显示遮罩视图。</p><p>Difference Layer选择用于比较的差值层，None表示没有层列表中的某一层。If Layer Sizes Differ用于当两层尺寸不同的时候。可以选择</p><p>Center将差值层放在源层中间比较，其它的地方用黑色填充：Stretch to Fit伸缩差值层，使两层尺寸一致，不过有可能使背景图像变形。</p><p>Matching Tolerance用于调整匹配范围。Matching Softness用于调整匹配的柔和程度。Blur Before Difference用于“模糊”比较的像素，</p><p>4,使用Extract抽取键控<br>Extract抽取键控根据指定的一个亮度范围来产生透明，亮度范围的选择基于通道的直方图(Histogram)，抽取键控适用于以白色或黑色为背景</p><p>拍摄的素材，或者前、后背景亮度差异比较大的情况，也可消除阴影。<br>控制参数如图。<br>直方图 用于显示从暗到亮的亮度标尺上分布的像素数量。<br>控制面板 用于调整透明的变化范围。<br>Channel 用于选择应用抽取键控的通道，可以选择Luminance亮度通道、Red 红色通道、Green绿色通道、Blue蓝色通道和Alpha透明通道。<br>Black Point 设置黑点，小于黑点的颜色透明。<br>White Point 设置白点，大于白点的颜色透明。<br>黑柔和 用于设置左边暗区域的柔和度。<br>白柔和 用于设置右边亮区域的柔和度。<br>lnvert 用于反转键控区域。<br>5,Inner Outer Key借助遮罩抠像<br>此特效须借助遮罩遮来实现，适用于动感不是很强的影片。用Inner Outer KeyInner 来处理毛发效果比较好！参数：</p><p>6，使用Linear Color Key线性色键<br>Linear Color Key线性色键是一个标准的线性键，线性键可以包含半透明的区域。线性色键根据RGB彩色信息或Hue色相及Chroma饱和度信息，</p><p>与指定的键控色进行比较，产生透明区域。之所以叫做线性键，是因为可以指定一个色彩范围作为键控色，它用于大多数对象，不适合半透明</p><p>对象。<br>素材视图 用于显示素材画面的略图。<br>预览视图 用于显示键控的效果。<br>键控滴管 用于在素材视图中选择键控色。<br>加滴管 用于为键控色增加颜色范围，从素材视图或预览视图中选择颜色。<br>减滴管 用于为键拧色减去颜色范田，从素材视图或预览视图中选择颜色。<br>View 用于切换预览窗口和合成窗口的视图，可以选择Final Output最终输出结果、Source Only显示源素材和Matte Only显示遮罩视图。<br>Key Color 设胃基本键控色，可以使用颜色方块选择或使用滴管工具在合成窗中选择。<br>Match colors 用于选择匹配颜色空间，可以选择Using RGB使用RGB彩色、<br>Using Hue 使用色相和Using Chorma使用饱和度。<br>Matching Tolerance 用于调控匹配范围。<br>MatchingSoftness 用于调整匹配的柔和程度。<br>KeyOperMion 用于选择Key Colors键出颜色和Keep Colors保留颜色。<br>7，Luma Key 使用亮键<br>对于明暗反差很大的图像，我们可以应用亮键，使背景透明，亮键设置某个亮度值为“阀值”，低厂或高于这个值的亮度设为透明。使用</p><p>LumaKey亮键的方法：<br>1．选择要应用亮键的层。（001.psd）应用Luma Key亮键<br>2-在Key Type处选择键控类型有四种可以选择（Key Out Brighter 键出的值大于阀值，把较亮的部分变为透明。Key Out Darker 键出值小于</p><p>阀值，把较暗的部分变为透明。<br>Key Out Similar键出阀值附近的亮度。Key Out Dissimilar 键出阀值范围之外的亮度。）<br>3－调整其它参数：<br>Threshold 用于设置阀值。<br>Tolerance 用于控制容差范围。值越小，亮度范围越小。<br>Edge Thin 用于调整键控边缘，正值扩大遮罩范围，负值缩小遮罩范围。<br>Edge Fether 用于羽化键控边缘。<br>在After Effects标准版中Color Key色键和Luma Key亮键都是属于二元键控”。即键控的图像，或者完全透明，或者完全不透明，没有半透明</p><p>的区域。这主要运用于有锐利边缘的固态对象，这是最简单的键控。<br>8，使用Spill puppressor溢出控制器<br>Spill Suppressor溢出控制器，可以去除键控后的图像残留的键控色的痕迹。滥出控制器用作上除图像边缘溢出的键控色，这些溢出的键控色</p><p>常常是由于背景的反射造成的。<br>ColorTo Suppress 用于设置“溢出颜色”。叮以刚滴管在应川的键控效果小，点击键控色的力块。<br>ColorAccuracy 用于算法的选择，可以选择Faster更快(主要针对红绿蓝色) 和Barter更好。<br>Suppressor用于设置抑制程度。<br>注意： 如果使用溢出控制器还不能得到满意的结果， 可以使用效果中的<br>Hue／Saturation色相／饱和度效果，降低饱和度，从而弱化键控色<br>9，使用Color Difference Key颇色差值键控<br>Color Difference Key颜色差值键控从不同的起始点把图像分成四个遮罩，即“遮罩A(Matte Partial A)”和“遮罩B(Matte Partial”。其</p><p>中．遮罩B是甚于键控色的，<br>而遮罩A是键控色之外的遮罩区域。然后组合两个遮罩，得到第三个遮罩，称为Alpha遮罩， Color Difference Key颜色差值键控产生一个明</p><p>确的透明值。 ‘<br>参数如图：<br>素材视图 用于显示源素材画面的略图。<br>遮罩视图 用于显示调整的遮罩情况，点下面的“A” “B” “a”分别察看“遮罩A”、 “遮罩B”和“Alpha遮罩”。<br>键控滴管 用于从素材视图中选择键控色。<br>黑滴管 用于在遮罩视图中选择透明区域。<br>白滴管 用于在遮罩视图中选择不透明区域。<br>View 用于切换合成窗口中的显示。可以选择多种视图。<br>Key Color用于选择键控色。可以使用调色板，或用滴管在合成成窗口或层窗口中选择。<br>Color Matching Accuracy 用于设置颜色匹配的精度， 可选择Fast更快或Accurate”更精确。<br>Partial A <em> 对遮罩A的参数精确调整。<br>Partial B </em> 对遮罩B的参数精确调整。<br>Matte * 用于对Alpha遮罩的参数精确调整。<br>注意：要键出蓝色背景，选择默认的蓝色(B-255)， 因为键控色和实际颜色的差别不会影响透明．使用白滴管，在Alpha遮罩视图中白色(不透</p><p>明)区域中最暗的部位点击，设置不透明区域。使用黑滴管，在Alpha遮翠视图中黑色(透明)区域中最亮的部位点击，设置透明区域。<br>另外，“键控技术”应和遮罩结合使用，效果会更加完美。以后我会逐步整理相关的资料，也请高手给予帮助！！！<br>一般高级键控常用的合成的方法：<br>（1）如果素材图像主要为蓝背景，首先用某种色键(如Color Difference Key颜色差值键)，建一个橙色固态层作为参考背景，通过遮罩视图(Matte View)调整键控范围，包括透明、半透明和不透明的区域.再使用Spill Suppressor溢出控制器，消除键控色留下的痕迹；Alpha Level调整Alpha通道的透明程度：Matte Choker遮罩堵塞工具凋整遮罩中的空洞．调整到满意后，在合成图像中，将固态层替换为新的背景素材。最后，根据素材变化，调整键控及遮罩参数，并设置关键帧，完成作品。<br>（2）对在蓝色或绿色背景中具有平稳亮度的素材键控的方法：<br>首先可以用Color Difference Key颜色差值键控，再用Spill Suppressor溢出控制器，清除键控色的痕迹。如果要求更高，还可 以使用Simple Choker简单堵塞工具和Matte Choker遮罩堵塞工具进行精细调整。如果结果还不满意，暂时关闭Color Difference Key，重新使用Linear Color Key线性色键。<br>（3） 对在蓝色或绿色背景中包含有多种颜色或亮度不稳定的素材键挖的方法：<br>首先应用Color Range颜色范围键控，再用Spill Suppressor溢出控制器和其它遮罩工具。如果结果不满意，重新使用或加入Linear Color Key线性色键。<br>（4）在黑暗和阴影的区域产生透明的方法：<br>先用Extract抽取键控，设置为Luminance Channel亮度通道。<br>（5）对固定背景(可以是复杂背景)应用键控的方法：<br>首先用Difference Matte差值遮罩键控，以单独的背景图层作为遮罩参考，进行差值。再加入Spill Suppressor溢出控制器和其它遮罩工具。<br>对于不同的实际情况，应该选择适当的键控方法，以得到满意的效果。对复杂的键控处理，可能要用到不同的键控才能得到满意的结果， 可以组合两个或者更多的键控和遮 罩。通过效果开关应用或不应用效果，观察键控效果。<br>十三，TIME效果<br>TIME效果提供和时间相关的特技效果，以原素材作为时间基准，在应用时间效果的时候，忽略其他使用的效果，TIME效果中有3个特效Echo\Posterize time\Time displacement.<br>1，Echo<br>称为“画面延续”或“时间延迟”，类似于声音效果里的回声效果，可以营造一种虚幻的感觉。而且，延续的画面可以比原画面早。Echo效果针对包含运动的画面，而且忽略遮罩和以前应用的特技效果。 效控参数如图；<br>时间类的特效比较简单，我就不举图例了！<br>Echo Time (seconds) 设置延时图像的产生时间，以秒为单位，正值为之后出现，负值为之前出现<br>Number Of Echoes 延续画面的数量<br>Starting Intensity 延续画面的透明度<br>Decay 设置延续画面的透明比例<br>Echo Operator 叠加模式设置如图<br>2，Posterize time<br>称为“抽帧效果”或叫“闪白”，这种效果经常会出现在传统的视频特技台上，将当前正常的播放速度调制到新的播放速度，但播放时长不变。如果低于标准速度，会产生跳跃现象。效控参数如图<br>Frame Rate调制到新的帧数。<br>3，Time displacement.<br>Time Displacement称为“时间替换效果”，可以在同一画面中反映出运动的全过<br>程。应用的时候要设置映射图层，然后基于图像的亮度值，将图像上明亮的区域替换为几秒钟以后该点的像素。<br>Time Displacement Layer选择时间替换层<br>MaxDisplacementTime(sec) 设置最大位移时间，以秒为单位。<br>Time Resolution(fps) 时间分辨率，这个值应该不大于层的标准播放速度.<br>If Layer Size Differ 如果替换层和原图像尺寸不同，选择Stretch Map to Fit拉伸替换图像<br>十四，Transition效果<br>Transition效果是一系列的转场效果，由于After Effects并非视频编辑软件，所以不<br>像Premiere那样提供了那么多种转场，况且在Premiere中转场是作用在两个镜头之间的，而在After Effects中转场作用在某一层图像上，所以两层之间的转场效果并不适用于多层合成的After Effects。<br>Transition中包含的转场效果有如下几种<br>1，Block Dissolve<br>Block Dissolve称为“板块叠化”，随机产生板块溶解图像。<br>Transition Completion转场完成百分比。<br>Block Width ／Block Height板块宽度／板块高度。<br>Feather板块边缘羽化。<br>2，Gradient Wipe<br>Gradient Wipe称为“渐变转场”，是依据两个层的亮度，值进行的，其中一个层叫渐变层(Gradient Layer)，用它进行参考。<br>Transition Completion转场完成百分比。<br>Transition Softness边缘柔化程度。<br>Gradient Layer选择渐变层进行参考。<br>Gradient Placement 渐变层的放置，包括居中、平铺和拉伸。<br>Invert Gradient渐变层反向，使亮度参考相反。<br>3，Iris Wipe<br>Iris Wipe以辐射状变化显示下面的画面，可以指定作用点、外半径及内半径来产生不同的辐射形状Iris Center 辐射中心位置<br>Iris Points—设置辐射多边形形状。<br>Outer Radius 外半径。<br>Inner Radius 内半径，要应用必须将UselnnerRadius打开。<br>Rotation 旋转设置。<br>Feather 边缘柔化。<br>4，Linear Wipe效果控制<br>Linear Wipe效果成为“线性扫画”。形成从某个方向的擦拭效果，扫画的效果和素材的质量有很大关系，在草稿质量下，图象边界的锯齿会较明显，最高质量下，经过反锯齿处理边界会变的平滑。利用此特效，可以扫出层中遮罩的内容。<br>Transition Completion 转场完成百分比。<br>Wipe Angle 转场角度。<br>Feather 边缘羽化。<br>5，RadialWipe称为“旋转扫画”<br>是通过旋转完成扫画。效果控制参数(如图7-220)o<br>Transition Completion转场完成百分比。<br>Start Angle 初始角度。<br>Wipe Center扫画中心位置。<br>Wipe 扫画类型，可以选择顺时针、逆时针两个方向<br>Feather边缘羽化。<br>6，Venetian Blinds<br>Venetian Blinds称为“百叶窗扫画”，过程类似百叶窗的开合。<br>Transition Completion 转场完成百分比。<br>Direction 设置方向。<br>Width设置宽度。<br>Feather 边缘羽化。<br>十五，Render效果<br>Render效果组里包含很多特效，（4 color Gradient/Advanced Lightning/Audio Spectrum/Audio Waveform/ Beam/Cell Pattern/Ellipse/Fill/Fractal/Fractal Noise/Grid/Lens Flare/Lightning/Radio Waves /Ramp/Stroke/Vegas）十七项—-没有在这里列举的是第三方插件，就不讲解了。可以创造一些原画面中没有的效果，而且这些效果在制作的过程中应用广泛、频繁，但After Effects毕竟不是一个绘图软件或三维动画软件，所以我们能够利用Render直接产生一些效果物件，才是简单易行的。我们可以使用 Adjustment Layer制造效果，而不影响其它层的图像。由于此类特效多应用于动态，所以一些详细的参数调整非常频繁，就不一一罗列了，具体参数调整动动手就有体会了。这里举的小例子只是体现了这个特效组万千变化中的一方面，要体会它的强大功能，只有自己去实践。另外，由于这组特效的特性关系，用于演示的GIF文件多了些，朋友们打开网页的速度可能会慢些，建议在个人属性里把每页显示帖子数改小点。<br>（一）4 color Gradient<br>4 color Gradient称为“四色渐变”，可以模拟霓虹灯，流光异彩等谜幻的效果。<br>效控界面如图：<br>Positions &amp; Colors用来设置四种颜色的中心点和各自的颜色。<br>Blend融合度<br>Opacity 透明度<br>Transfer Mode叠加模式<br>（二）Advanced Lightning 可以称为“高级闪电效果”。<br>控制参数如图<br>Lightning Type闪电的类型 ：Direction，Strike，Breaking，Bouncey，Omni ，Anywhere，Vertical ，Two-Way Strike<br>Origin起始位置<br>Direction结束位置<br>Conductivity State状态设置<br>Core Settings用来设置闪电主干和分支的颜色/半径透明度等<br>Glow Settings用来设置闪电外围辐射的颜色/半径/透明度等<br>Alpha Obstacle<br>Turbulence混乱程度<br>Forking 设置闪电的分支<br>Decay 衰减设置<br>Decay Main Core<br>Add to Original<br>Expert Settings高级设置<br>在高级设置Expert Settings中又包含如下参数控制，这里就不一一详述了。<br>Complexity 设置闪电的复杂程度<br>Min. Forkdistance调整闪电分支延展长度和稀密度<br>Termination Threshold调整闪电分支的极限（长短，强弱）<br>Main Core Collision Only<br>Fractal Type分型模式<br>Core Drain设置闪电主干核心的衰减度<br>Fork Strength设置分支强度变化<br>Fork Variation设置分支变化频率<br>（三）Audio Spectrum称为“音频图像”<br>Audio Spectrum用于产生音频频谱，有力地推动音乐感染力，效果控制参数<br>Audio Layer选择合成中的音频参考层。<br>Strar Point起点位置。<br>End Point终点位置。<br>Path选择路径。可以用笔工具在层窗产生一个路径，让波形沿路径变化。<br>Start Frequency起始频率，设置参考的最低音频频率,人耳的听觉范围是20－20000 HZ。<br>End Frequency截止频率。<br>Maximum Height频谱显示的振幅。<br>Audio Duration波形保持时长。<br>Audio offset波形位移。<br>Thickness波形宽度。<br>Softness软边程度。<br>inside Color中间颜色。<br>outside Color外围颜色。<br>Hue Interpolation颜色插值。<br>Dynamic Hue Phase颜色相位变化。<br>Color Symmetry颜色对称。<br>Display option显示设置，可以选择 Digital显示数值波形， Analog Line显示模拟谱线和Analog Dots显示模拟频点。<br>Side Option边缘设置，可以选择半边或整个波形显示。<br>Duration Averaging平均化。<br>Composite on original和原画面合成。这样既可以显示原画面，又可以叠加音频谱线。但我们最好新建一个 Adjustment Layer来应用此效果。<br>（四）Audio Waveform称为“音乐波形”。<br>Audio Waveform用于产生音频波形，和上面的Audio Spectrum音频频谱差不多，如果用电子工程来解释就是一个表示“时间域”，一个表示“频域”。由于上面已经详细介绍各项参数，两种设置大体相同，所以就不再详述。效控参数如图<br>（五）Beam<br>Beam称为“激光束效果”，用来模拟激光束移动，如图所示<br>效果控制参数<br>Starting Point起点。<br>Ending Point终点。<br>Length长度。<br>Time时间。<br>Starting Thickness起点宽度，可以设置为梯形<br>Softness边缘柔化。<br>Inside Color中间颜色。<br>Outside Color外围颜色。<br>3D Perspective三维纵深。<br>Composite on original和画面合成。<br>（六）Cell Pattern称为“纹理或细胞”效果<br>Cell Pattern纹理（细胞）类（Bubbles/Crystals/Plates/Static Plates/Crystallize/<br>Pillow/Crystals HQ/Plates HQ/Static Plates HQ/CrystalliMixed Crystals/Tubular）<br>Invert反转<br>Contrast 对比度<br>Overflow溢出设置（ Clip/Soft Clamp/Wrap Back）<br>Disperse 分散设置<br>Size 大小尺寸的设置<br>Offset偏移设置<br>Tiling Options模拟陶瓷效果的相关设置<br>（Enable Tiling–Cells Horizontal/Cells Vertical）<br>Evolution 发展运动变化设置<br>Evolution Options<br>Cycle Evolution循环设置<br>Cycle (in Revolutions) 旋转循环<br>Random Seed 随机速度<br>（七）Ellipse<br>Ellipse用来产生椭圆形，也可以模拟激光圈等，如图所示<br>效果控制参<br>Center椭圆位置。<br>Width宽度。<br>Hight高度。<br>Thickness边缘厚度。<br>Softness边缘柔化。<br>Inside／Outside Color中间／外围色。<br>Composite On Original与画面合成。<br>（八）Fill<br>Fill称为“填充效果”，可以向图层的遮罩中填充颜色，如图所示<br>Fill Mask选择要填充的遮罩。<br>Color选择颜色。<br>Horizontal Feather水平边缘羽化。<br>Vertical Feather垂直边缘羽化。<br>Opacity不透明度。<br>（九）Fractal称为“万花筒”，可以用来模拟细胞体，制作分型效果等。<br>参数如下Set Choice精细设置，有六种模式 （Mandelbrot/Mandelbrot Inverse/Mandelbrot over Julia/Mandelbrot Inverse over Julia/Julia/Julia Inverse）<br>Equation方程式 （ z = z^3 + c/z = z^5 + c/z = z^7 + c/z = z^2 + c/z = z^3 + c）Mandelbrot（X (Real)/Y<br>(Imaginary)/Magnification/Escape Limit）Julia（ X (Real)/Y (Imaginary)/Magnification（放大倍率）/Escape Limit（溢出限定））<br>Post-inversion offset（X (Real)/Y (Imaginary)）<br>Color{Overlay（再叠加一种纹理）/Transparency/Palette（Lightness Gradient/Hue Wheel/Black And White/Solid Color/Escape Angle/Grayscale/Apple ][）/Hue/Cycle Steps/Cycle Offset /Edge Highlight (Force LQ)）<br>High Quality Settings高质量设置{Oversample Method（Edge Detect-Fast-May miss pixels/Brute Force-Slow-Every pixel）/Oversample Factor}<br>（十）Fractal Noise称为“分形噪波”。<br>可以模拟纹理图案/烟/云/水流等。详细的应用，大家可以参考《AE5.5影视合成风暴》<br>第53页第3章After Effects常用基础特效：）<br>Fractal Type各类分形算法方式<br>Noise Type噪波类型<br>Invert反转<br>Contrast对比度<br>Brightness明亮度<br>Overflow溢出处理<br>Transform变换设置<br>Complexity复杂度<br>Sub Settings噪波的子分形变化的相关设置（如子分行影响力、子分形缩放等）<br>Evolution控制噪波的分行变化相位<br>Evolution Options控制分形变化的一些设置（循环、随机种子等）<br>Opacity不透明度<br>Transfer Mode叠加模式<br>这一部分动态性非常强，应用也非常繁复，用静态方式讲清楚这部份知识，我还没那本事，<br>（十一）Grid称为“网格”效果<br>Anchor（Corner Point/Width Slider/Width &amp; Height Sliders）<br>Gridsize From<br>Corner<br>Width宽度<br>Height高度<br>Border<br>Feather羽化<br>Invert Grid<br>Color颜色<br>Opacity 不透明度<br>Transfer Mode变换模式<br>效控参数如图。应用Grid与Bulge<br>（十二）Lighting<br>Lighting称为“闪电效果”，可以用来模拟真实的闪电和放电效果，并自动设置动画。<br>Start／End Point起始／结束位置。<br>Segments段数。分段数越多，闪电越扭曲。<br>Amplitude幅度。<br>Detail Level精细程度。<br>Detail Amplitude细节幅度。<br>Branching分支数量。<br>Rebranching再分支数量。<br>Branch Seg． Length分支线段长度。<br>Branch Segments分支段数。<br>Branch Width分支宽度。<br>Speed闪电变化速度。<br>Stability稳定性。较高的数值使闪电变化剧烈。<br>Fixed Endpoint固定结束点。<br>Width闪电宽度。<br>Width Varation宽度变化。<br>Core Width核心宽度。<br>Outside Color外围颜色。<br>Inside Color内部颜色。<br>Pull Force拉力。<br>Pull Direction拉力方向。<br>Random Speed随机速度。<br>Blending Mode叠加模式。<br>Simulation选择 Rerun At Each Frame使每一帧重新生成闪电.<br>（十三）Lens Flare<br>Lens Flare称为“镜头光斑”，模拟镜头照到发光物体上，由于经过多片镜头能<br>产生很多光环，这是后期制作中经常使用的提升画面效果的手段，如图所示。<br>Flare Center光斑位置。<br>Flare Brightness光斑亮度。<br>Lens Type镜头类型<br>Blend With Original和图像混合程度。<br>（十四）Radio waves称为“电波扩散效果”<br>Producer Point 电波产生的核心点<br>Parameters are set at<br>Render Quality质量补偿控制<br>Wave Type电波的类型<br>Polygon多边形控制<br>Image Contour图象控制（当Wave Type选Image Contour有效）<br>Mask遮罩选择（当Wave Type选NASK时有效）<br>Wave Motion波形运动设置<br>Stroke波形描边设置<br>（十五）Ramp<br>Ramp用来创建彩色渐变，使产生的黑白渐变为应用层模式（ Blend Mode）和原图像 混合，如图所示。<br>Start of Ramp渐变起点。<br>Start Color起点颜色。<br>End of Ramp渐变终点。<br>End Color终点颜色。<br>Ramp Scatter渐变扩散。<br>BIend With original和原图像混合<br>（十六）Stroke<br>Stroke称为“描边效果”，可以沿路径或遮罩产生边框，可以模拟手绘过程，如图<br>所示。<br>Path选择遮罩或路径。<br>Color选择颜色。<br>Brush Size画笔粗细。<br>Brush Hardness设置画笔边缘。<br>Opacity不透明度。<br>start设置起点。可以设置动画产生绘画过程。<br>End设置终点。<br>Spacing指定笔触的间隔。<br>Paint on选择应用到 original原画面还是 Transparent透明层<br>（十七）Vegas描边特效的一种，就不一一解释了！实践一下就有体会了！<br>Vegas特效可以自动捕捉图象的暗、亮部分。<br>Stroke（Image Contours和Mask/Path）<br>Segments调整这部分可以有霓虹灯的效果</p>]]></content>
      
      <categories>
          
          <category> 后期合成 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>particleIllusion</title>
      <link href="/5a951a2b.html"/>
      <content type="html"><![CDATA[<h3 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h3><p>particle：分子，是Illusion基本构成元素</p><p>particle type：分子类型，决定分子的行为、颜色、速率、大小、重量等</p><p>Emitters：发射器，由单一或多个分子构成</p><p>Defiectors：偏向板，可见或不可见的障碍，分子会与之撞击</p><p>Bllgckers：隐藏板，舞台上的一个区域，分子进入后会不可见</p><h3 id="二、创建步骤："><a href="#二、创建步骤：" class="headerlink" title="二、创建步骤："></a>二、创建步骤：</h3><p>1）选中一个粒子放在舞台上</p><p>2）在时间轴上选定一个时间，然后拖放粒子</p><p>3）为止调节，必须在关键帧处，右键</p><p>4）保存</p><h3 id="三、粒子库"><a href="#三、粒子库" class="headerlink" title="三、粒子库"></a>三、粒子库</h3><pre><code>在粒子库区域右键，快速载入可有默认选择，载入粒子库可选择别处粒子库</code></pre><h3 id="四、技法"><a href="#四、技法" class="headerlink" title="四、技法"></a>四、技法</h3><pre><code>舞台上单击右键，可调节背景色，拉近/远镜头（缩放），居中对齐等在关键帧上添加粒子，邮件—&gt;记录位置数据，可任意绘制路径供粒子移动</code></pre><p>注：此路径在粒子结束前必须描绘完，并且只能修改粒子疏密而无法修改路径</p><p>技法（路径）</p><pre><code>在关键帧上右键—&gt;弯曲，可调整曲度和张力，再右键选择连接时，左右拉杆关联，取消连接时，可单独调节。快捷键：alt</code></pre><p>技法（速度）</p><pre><code>通过弯曲手柄调节，每个点均设成转角，用拉杆来调节疏密，越密越快！</code></pre><h3 id="五、Emmitter常用属性："><a href="#五、Emmitter常用属性：" class="headerlink" title="五、Emmitter常用属性："></a>五、Emmitter常用属性：</h3><p>1）Active：用来决定何时产生particle</p><p>2）Life：生命周期，决定particle的消失时间</p><p>3）Size：表示particle的大小</p><p>4）Velocity：加速度，表示particle陪出后移动的速度</p><p>5）Weight：重量，用来控制particle降落的速度以及上升的速度 注2</p><p>6）Zoom：放大或缩小，也可用远近的感觉来形容</p><p>7）Tint &amp; Tint strength：改变emitter内particle的颜色</p><p>8）Emission angle &amp; Emission rang：喷射角度及喷射范围，用来决定<br>                                                             particle喷射的方向 注1</p><p>9）Number：喷出particle的数量</p><p>10）Spin：控制particle的旋转 （同注2，也必须调particle的属性）</p><p>注1：当Emission rang的值为360时，Emission angle的变化将看不出来，所以调整Emission角度之前，必须先调整Emission的范围（不能是360°）</p><p>注2：想调整weight，应调整particle的weight，而不是Emitter的weight，当particle的weight为正值则particle下落，为零时代表无重力状态，会向四面八方喷射，为负值则向上飘</p>]]></content>
      
      <categories>
          
          <category> 后期合成 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
